function shuffleArray(arr) {
    const c = arr.slice();
    for (let i = c.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [c[i], c[j]] = [c[j], c[i]];
    }
    return c;
}

function prepareExamData() {
  examData.files = []; examData.subjectNames = []; examData.keys = []; examData.originalOrder = [];
  
  // Define EXACT question ranges for each subject as per your requirement
  const subjectRanges = [
    { name: "Maths", start: 1, end: 30 },      // Maths: Q1-30
    { name: "Physics", start: 31, end: 45 },   // Physics: Q31-45
    { name: "Chemistry", start: 46, end: 60 }  // Chemistry: Q46-60
  ];
  
  let groups = [];
  
  // Create groups for each subject with their EXACT question ranges
  subjectRanges.forEach(subject => {
    const subjectQuestions = [];
    const subjectKeys = [];
    const subjectOriginalOrder = [];
    
    // Collect EXACT questions for this subject range
    for (let i = subject.start; i <= subject.end; i++) {
      const imgIndex = i - 1; // Convert to 0-based index for arrays
      if (images[imgIndex] && answerKey[imgIndex]) {
        subjectQuestions.push(images[imgIndex]);
        subjectKeys.push(answerKey[imgIndex]);
        subjectOriginalOrder.push(imgIndex);
      }
    }
    
    console.log(`${subject.name}: ${subjectQuestions.length} questions (${subject.start}-${subject.end})`);
    
    // Shuffle questions WITHIN this subject
    const shuffledIndices = shuffleArray([...Array(subjectQuestions.length).keys()]);
    
    groups.push({
      name: subject.name,
      imgs: shuffledIndices.map(i => subjectQuestions[i]),
      keys: shuffledIndices.map(i => subjectKeys[i]),
      originalOrder: shuffledIndices.map(i => subjectOriginalOrder[i])
    });
  });
  
  // Shuffle the SUBJECTS themselves
  const shuffledGroups = shuffleArray(groups);
  
  // Build final exam data
  shuffledGroups.forEach(g => {
    g.imgs.forEach((img, i) => {
      examData.files.push(img);
      examData.keys.push(g.keys[i]);
      examData.subjectNames.push(g.name);
      examData.originalOrder.push(g.originalOrder[i]);
    });
  });
  
  console.log("Final exam structure:");
  console.log("Total questions:", examData.files.length);
  console.log("Subject distribution:", examData.subjectNames);
}

["stuName", "stuSection", "stuRoll", "stuAdm"].forEach(id => {
  document.getElementById(id).addEventListener("input", validateStudentInputs);
});

// FIXED: Start button click handler - now properly shows confirmation
document.getElementById('stuStartBtn').onclick = () => { 
  if (!validateStudentInputs()) return; 
  showConfirm("Start Exam?", startWithSecurity); 
};

function startWithSecurity(ok) {
  if (!ok) return;
  const stuName = document.getElementById('stuName');
  const stuSection = document.getElementById('stuSection');
  const stuRoll = document.getElementById('stuRoll');
  const stuAdm = document.getElementById('stuAdm');
  
  const studentKey = `${stuName.value}|${stuSection.value}|${stuRoll.value}|${stuAdm.value}`;
  const stored = localStorage.getItem(studentKey), now = Date.now();
  if (stored && now - stored < 86400000) {
    document.getElementById('fullRedOverlay').style.display = "block"; 
    document.getElementById('accessDeniedBox').style.display = "block";
    document.getElementById('callAdminBtn').onclick = () => {
      document.getElementById('adminPassModal').style.display = "flex";
      document.getElementById('adminPassInput').focus();
      document.getElementById('adminPassSubmit').onclick = () => {
        const adminPassInput = document.getElementById('adminPassInput');
        if (adminPassInput.value === "lfjc2025") {
          document.getElementById('adminPassModal').style.display = "none";
          document.getElementById('fullRedOverlay').style.display = "none"; 
          document.getElementById('accessDeniedBox').style.display = "none";
          startExam(studentKey);
        } else alert("Incorrect password!");
      };
    };
  } else startExam(studentKey);
}

function startExam(studentKey) {
  // ensure key is loaded
  if (!keyLoaded) {
    alert('Answer key not loaded. Contact admin.');
    return;
  }

  const stuName = document.getElementById('stuName');
  const stuSection = document.getElementById('stuSection');
  const stuRoll = document.getElementById('stuRoll');
  const stuAdm = document.getElementById('stuAdm');

  localStorage.setItem(studentKey, Date.now());
  prepareExamData();
  progress = {
    answers: Array(examData.files.length).fill(null),
    review: Array(examData.files.length).fill(false),
    currentIndex: 0,
    student: {name: stuName.value, sec: stuSection.value, roll: stuRoll.value, adm: stuAdm.value},
    timeLeftSec: EXAM_DURATION_MINUTES * 60
  };

  // Set exam start time
  examStartTime = Date.now();
  
  document.getElementById('studentEntry').style.display = "none";
  document.getElementById('examArea').style.display = "block";
  renderQuestion(); 
  renderPalette(); 
  startTimer(); 
  updateNavButtons();
  
  // Initialize backup status
  updateBackupStatus();
  
  // Start smart periodic backup
  startPeriodicBackup();
  
  // Check if already submitted
  if (checkIfAlreadySubmitted(progress.student.roll, assignedForm)) {
    showSubmissionStatus(true);
  }
  
  // Preload all images for smooth transitions
  preloadQuestionImages();
  
  // Setup enhanced screenshot protection
  setupScreenshotProtection();
  
  // Setup keyboard navigation
  setupKeyboardNavigation();
  setupModalKeyboardSupport();
}

function startTimer() {
  const timerEl = document.getElementById('timerEl');
  const stuInfo = document.getElementById('stuInfo');
  const stuQInfo = document.getElementById('stuQInfo');
  const examHeader = document.getElementById('examHeader');
  
  timerInterval = setInterval(() => {
    if (progress.timeLeftSec <= 0) { clearInterval(timerInterval); submitExam(); return; }
    progress.timeLeftSec--;
    let m = Math.floor(progress.timeLeftSec / 60), s = progress.timeLeftSec % 60;
    timerEl.textContent = `üïí ${String(m).padStart(2, "0")}:${String(s).padStart(2, "0")}`;
    stuInfo.textContent = `${progress.student.name} | ${progress.student.sec} | ${progress.student.roll} | ${progress.student.adm}`;
    stuQInfo.textContent = `${examData.subjectNames[progress.currentIndex]} | Q ${progress.currentIndex + 1}/${examData.files.length}`;

    if (progress.timeLeftSec <= 300 && progress.timeLeftSec > 60) {
        timerEl.classList.add("blink");
    } else { timerEl.classList.remove("blink"); }

    if (progress.timeLeftSec <= 60) {
        timerEl.classList.add("blink");
        examHeader.classList.add("blinkLine");
    } else {
        examHeader.classList.remove("blinkLine");
    }
  }, 1000);
}

function renderQuestion() {
  const i = progress.currentIndex;
  const f = examData.files[i];
  const questionContainer = document.getElementById('questionContainer');
  
  // Clear previous content with smooth transition
  questionContainer.style.opacity = '0';
  
  setTimeout(() => {
    // Check if image is preloaded
    if (preloadedImages[f]) {
      // Use preloaded image for instant display
      questionContainer.innerHTML = '';
      const img = preloadedImages[f].cloneNode();
      img.className = "questionImg question-fade-in";
      img.alt = `Question ${i + 1}`;
      questionContainer.appendChild(img);
      questionContainer.appendChild(document.createElement('br'));
      renderOptions(i, questionContainer);
      questionContainer.style.opacity = '1';
    } else {
      // Fallback to normal loading with minimal delay
      questionContainer.innerHTML = '<div class="loading-message">Loading question...</div>';
      
      const img = new Image();
      img.className = "questionImg";
      img.src = f;
      img.alt = `Question ${i + 1}`;
      
      img.onerror = function() {
        console.error(`Failed to load image: ${f}`);
        questionContainer.innerHTML = `
          <div class="image-error">
            <h3>‚ùå Image Not Found</h3>
            <p>Could not load: ${f}</p>
            <p>Please check that the image file exists in the questions folder.</p>
            <p><strong>Expected file:</strong> ${f}</p>
          </div>
          <br>`;
        
        // Still show options even if image fails
        renderOptions(i, questionContainer);
        questionContainer.style.opacity = '1';
      };
      
      img.onload = function() {
        questionContainer.innerHTML = '';
        questionContainer.appendChild(img);
        questionContainer.appendChild(document.createElement('br'));
        renderOptions(i, questionContainer);
        questionContainer.style.opacity = '1';
        
        // Cache the loaded image
        preloadedImages[f] = img.cloneNode();
      };
    }
  }, 150); // Small delay for smooth transition
}

function renderOptions(questionIndex, container) {
  const optsDiv = document.createElement("div");
  optsDiv.className = "options-container";
  optsDiv.style.marginTop = "50px";
  
  ["A", "B", "C", "D"].forEach(opt => {
    let b = document.createElement("button"); 
    b.className = "optBtn"; 
    b.style.margin = "0 40px";
    b.textContent = opt;
    b.tabIndex = 0; // Make options focusable
    if (progress.answers[questionIndex] === opt) b.classList.add("selected");
    b.onclick = () => { 
      progress.answers[questionIndex] = (progress.answers[questionIndex] === opt ? null : opt); 
      renderPalette(); 
      updateOptionsDisplay();
      // üõ°Ô∏è CRITICAL: Backup answer immediately
      backupAnswerToLocal(questionIndex, progress.answers[questionIndex]);
    };
    optsDiv.appendChild(b);
  });
  
  container.appendChild(optsDiv);
}

// NEW FUNCTION: Update options display without reloading entire question
function updateOptionsDisplay() {
  const i = progress.currentIndex;
  const optionButtons = document.querySelectorAll('.optBtn');
  
  optionButtons.forEach((btn, index) => {
    const optionLetter = ['A', 'B', 'C', 'D'][index];
    if (progress.answers[i] === optionLetter) {
      btn.classList.add("selected");
    } else {
      btn.classList.remove("selected");
    }
  });
}

document.getElementById('prevBtn').onclick = () => { 
  if (progress.currentIndex > 0) { 
    progress.currentIndex--; 
    renderQuestion(); 
    renderPalette(); 
    updateNavButtons(); 
  } 
};

document.getElementById('nextBtn').onclick = () => { 
  if (progress.currentIndex < examData.files.length - 1) { 
    progress.currentIndex++; 
    renderQuestion(); 
    renderPalette(); 
    updateNavButtons(); 
  } 
};

document.getElementById('markReviewBtn').onclick = () => { 
  progress.review[progress.currentIndex] = !progress.review[progress.currentIndex]; 
  document.getElementById('markReviewBtn').textContent = progress.review[progress.currentIndex] ? "Unreview" : "Review"; 
  renderPalette(); 
};

// üõë ENHANCED SUBMIT BUTTON WITH DUPLICATE PREVENTION
document.getElementById('submitBtn').onclick = () => {
    // üõë Check if already submitted
    if (checkIfAlreadySubmitted(progress.student.roll, assignedForm)) {
        showConfirm(
            "üìã You've already submitted this exam. Submit again?", 
            (ok) => { 
                if (ok) {
                    // Force resubmission
                    submitExam(); 
                }
            }
        );
        return;
    }
    
    // üõë Validate backup before submission
    const backupValidation = validateBackupBeforeSubmission();
    
    if (!backupValidation.isValid) {
        showConfirm(
            `üö® BACKUP WARNING: ${backupValidation.message}. Submit anyway?`, 
            (ok) => { if (ok) submitExam(); }
        );
    } else {
        showConfirm("Submit Exam?", (ok) => { if (ok) submitExam(); });
    }
};

function updateNavButtons() {
  const prevBtn = document.getElementById('prevBtn');
  const nextBtn = document.getElementById('nextBtn');
  const markReviewBtn = document.getElementById('markReviewBtn');
  
  prevBtn.style.display = progress.currentIndex === 0 ? "none" : "inline-block";
  nextBtn.style.display = progress.currentIndex === examData.files.length - 1 ? "none" : "inline-block";
  markReviewBtn.textContent = progress.review[progress.currentIndex] ? "Unreview" : "Review";
}

function renderPalette() {
  const paletteContainer = document.getElementById('paletteContainer');
  paletteContainer.innerHTML = "";
  
  // Grid layout will be handled by CSS media queries
  paletteContainer.style.display = "grid";

  progress.answers.forEach((ans, i) => {
    const b = document.createElement("button"); 
    b.textContent = i + 1;
    b.tabIndex = 0; // Make palette buttons focusable
    if (progress.review[i]) b.classList.add("reviewed");
    if (i === progress.currentIndex) b.classList.add("current");
    if (ans) b.classList.add("selected");
    b.onclick = () => { progress.currentIndex = i; renderQuestion(); renderPalette(); updateNavButtons(); };
    paletteContainer.appendChild(b);
  });
}

document.addEventListener("visibilitychange", () => {
  if (document.hidden && progress) {
    // üõ°Ô∏è CRITICAL: Backup all answers when tab becomes hidden
    progress.answers.forEach((answer, index) => {
      if (answer !== null) {
        backupAnswerToLocal(index, answer);
      }
    });
    console.log("üíæ Auto-backed up all answers due to tab visibility change");
  }
});

function submitExam() {
    if (hasSubmitted && !checkIfAlreadySubmitted(progress.student.roll, assignedForm)) return; // Prevent multiple submissions unless forced
    clearInterval(timerInterval);
    if (autoBackupInterval) {
        clearInterval(autoBackupInterval);
    }
    
    const subjData = {};
    examData.subjectNames.forEach((s, i) => {
        // Use the helper function for standardized subject names
        const subjectName = identifySubject(s);
        if (!subjData[subjectName]) subjData[subjectName] = {correct: 0, wrong: 0, blank: 0, total: 0, marks: 0};
        
        const ans = progress.answers[i];
        if (ans === null) {
            subjData[subjectName].blank++;
        } else if (ans === examData.keys[i]) {
            subjData[subjectName].correct++;
            subjData[subjectName].marks += MARK_PER_CORRECT;
        } else {
            subjData[subjectName].wrong++;
            subjData[subjectName].marks += MARK_PER_WRONG;
        }
        subjData[subjectName].total++;
    });

    // Store subject data for detailed solutions
    currentSubjData = subjData;

    // üéØ CHANGED: Use Multi-Form Google Forms instead of single form
    sendToGoogleForm(subjData, progress.student);

    // Show summary interface
    showSummaryInterface(subjData);
}

function showSummaryInterface(subjData) {
  document.getElementById('examArea').style.display = "none";
  document.getElementById('summaryArea').style.display = "block";
  
  // Set student info in summary
  document.getElementById('summaryStudentName').textContent = progress.student.name;
  document.getElementById('summarySection').textContent = progress.student.sec;
  document.getElementById('summaryRoll').textContent = progress.student.roll;
  document.getElementById('summaryAdm').textContent = progress.student.adm;
  document.getElementById('summaryForm').textContent = assignedForm;
  
  renderSummaryTable(subjData);
  
  // Check if exam time has actually completed
  const timeElapsed = Date.now() - examStartTime;
  const timeCompleted = timeElapsed >= EXAM_DURATION_MS;
  
  if (timeCompleted) {
    // Auto transition to detailed solutions after 3 seconds
    startAutoTransition();
  } else {
    // Start waiting timer
    startWaitingTimer(timeElapsed);
  }
}

function startWaitingTimer(timeElapsed) {
    const timeRemaining = EXAM_DURATION_MS - timeElapsed;
    const waitingTimerElement = document.getElementById('waitingTimer');
    
    // Update timer immediately
    updateWaitingTimer(timeRemaining, waitingTimerElement);
    
    // Start interval to update timer every second
    waitingTimerInterval = setInterval(() => {
        timeElapsed = Date.now() - examStartTime;
        const timeRemaining = EXAM_DURATION_MS - timeElapsed;
        
        updateWaitingTimer(timeRemaining, waitingTimerElement);
        
        // Check if time is completed
        if (timeRemaining <= 0) {
            clearInterval(waitingTimerInterval);
            startAutoTransition();
        }
    }, 1000);
}

function updateWaitingTimer(timeRemaining, timerElement) {
    const minutes = Math.floor(timeRemaining / 60000);
    const seconds = Math.floor((timeRemaining % 60000) / 1000);
    timerElement.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
}

function startAutoTransition() {
    // Clear waiting timer if exists
    if (waitingTimerInterval) {
        clearInterval(waitingTimerInterval);
        waitingTimerInterval = null;
    }
    
    let countdown = 3;
    const countdownElement = document.getElementById('countdown');
    const autoTransitionMessage = document.getElementById('autoTransitionMessage');
    const waitingMessage = document.getElementById('waitingMessage');
    
    // Hide waiting message and show auto-transition message
    waitingMessage.style.display = 'none';
    autoTransitionMessage.style.display = 'block';
    
    // Start countdown
    autoTransitionTimer = setInterval(() => {
        countdown--;
        countdownElement.textContent = countdown;
        
        if (countdown <= 0) {
            clearInterval(autoTransitionTimer);
            showReviewInterface();
        }
    }, 1000);
}

function renderSummaryTable(subjData) {
  const container = document.getElementById('summaryTableContainer');
  
  let totalCorrect = 0, totalWrong = 0, totalBlank = 0, totalQs = 0, totalMarks = 0;
  
  // Calculate totals
  for (let s in subjData) {
    totalCorrect += subjData[s].correct;
    totalWrong += subjData[s].wrong;
    totalBlank += subjData[s].blank;
    totalQs += subjData[s].total;
    totalMarks += subjData[s].marks;
  }
  
  let totalPer = totalQs > 0 ? ((totalCorrect / totalQs) * 100).toFixed(2) : 0;
  
  let html = `<table class="results-table" border="1">
    <tr style="background:#E6E6FA;">
      <th>Subject</th><th>Correct</th><th>Wrong</th><th>Blank</th><th>Score</th><th>Percentage</th>
    </tr>`;

  for (let s in subjData) {
    let v = subjData[s];
    let per = ((v.correct / v.total) * 100).toFixed(2);
    html += `<tr>
      <td>${s}</td>
      <td>${v.correct}</td>
      <td>${v.wrong}</td>
      <td>${v.blank}</td>
      <td>${v.marks.toFixed(2)}</td>
      <td>${per}%</td>
    </tr>`;
  }

  html += `<tr style="font-weight:bold;background:#D8BFD8;">
    <td>Total</td>
    <td>${totalCorrect}</td>
    <td>${totalWrong}</td>
    <td>${totalBlank}</td>
    <td>${totalMarks.toFixed(2)}</td>
    <td>${totalPer}%</td>
  </tr></table>`;

  container.innerHTML = html;
}

function showReviewInterface() {
    // Clear any existing timers
    if (waitingTimerInterval) {
        clearInterval(waitingTimerInterval);
        waitingTimerInterval = null;
    }
    if (autoTransitionTimer) {
        clearInterval(autoTransitionTimer);
        autoTransitionTimer = null;
    }
    
    document.getElementById('summaryArea').style.display = "none";
    document.getElementById('reviewArea').style.display = "block";
    
    // Set student info in review
    document.getElementById('reviewStudentName').textContent = progress.student.name;
    document.getElementById('reviewSection').textContent = progress.student.sec;
    document.getElementById('reviewRoll').textContent = progress.student.roll;
    document.getElementById('reviewAdm').textContent = progress.student.adm;
    document.getElementById('reviewForm').textContent = assignedForm;
    
    // Render detailed results table
    renderDetailedResultsTable();
    
    // Render review questions
    renderReviewQuestions();
}

// NEW FUNCTION: Render detailed results table in review area
function renderDetailedResultsTable() {
  const container = document.getElementById('detailedResultsContainer');
  
  if (!currentSubjData) return;
  
  let totalCorrect = 0, totalWrong = 0, totalBlank = 0, totalQs = 0, totalMarks = 0;
  
  // Calculate totals
  for (let s in currentSubjData) {
    totalCorrect += currentSubjData[s].correct;
    totalWrong += currentSubjData[s].wrong;
    totalBlank += currentSubjData[s].blank;
    totalQs += currentSubjData[s].total;
    totalMarks += currentSubjData[s].marks;
  }
  
  let totalPer = totalQs > 0 ? ((totalCorrect / totalQs) * 100).toFixed(2) : 0;
  
  let html = `
    <div style="width:100%;max-width:900px;margin:0 auto;">
      <h3 style="color:#4B0082; text-align:center; margin-bottom:20px;">üìä Final Results Summary - Form ${assignedForm}</h3>
      <table class="detailed-results-table" border="1">
        <tr>
          <th>Subject</th><th>Correct</th><th>Wrong</th><th>Blank</th><th>Score</th><th>Percentage</th>
        </tr>`;

  for (let s in currentSubjData) {
    let v = currentSubjData[s];
    let per = ((v.correct / v.total) * 100).toFixed(2);
    html += `<tr>
      <td><strong>${s}</strong></td>
      <td>${v.correct}</td>
      <td>${v.wrong}</td>
      <td>${v.blank}</td>
      <td>${v.marks.toFixed(2)}</td>
      <td>${per}%</td>
    </tr>`;
  }

  html += `<tr class="total-row highlight">
    <td><strong>GRAND TOTAL</strong></td>
    <td><strong>${totalCorrect}</strong></td>
    <td><strong>${totalWrong}</strong></td>
    <td><strong>${totalBlank}</strong></td>
    <td><strong>${totalMarks.toFixed(2)}</strong></td>
    <td><strong>${totalPer}%</strong></td>
  </tr></table>
    </div>`;

  container.innerHTML = html;
}

function renderReviewQuestions() {
  const container = document.getElementById('reviewQuestionsContainer');
  container.innerHTML = '';
  
  // Render each question with answers
  examData.files.forEach((file, index) => {
    const questionDiv = document.createElement('div');
    questionDiv.style.marginBottom = '30px';
    questionDiv.style.padding = '20px';
    questionDiv.style.border = '2px solid #E6E6FA';
    questionDiv.style.borderRadius = '10px';
    questionDiv.style.background = 'white';
    
    const studentAnswer = progress.answers[index];
    const correctAnswer = examData.keys[index];
    let status = '';
    let statusClass = '';
    
    if (studentAnswer === null) {
      status = 'Not Attempted';
      statusClass = 'not-attempted';
    } else if (studentAnswer === correctAnswer) {
      status = 'Correct';
      statusClass = 'correct';
    } else {
      status = 'Wrong';
      statusClass = 'wrong';
    }
    
    questionDiv.innerHTML = `
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
        <h4 style="margin:0; color:#4B0082;">Question ${index + 1} - ${examData.subjectNames[index]}</h4>
        <div class="answer-status ${statusClass}">${status}</div>
      </div>
      <img src="${file}" class="questionImg" style="max-width:100%; margin-bottom:20px;" onerror="this.alt='Image not available: ${file}'">
      <div style="margin-top:20px;">
        <h4 style="color:#4B0082; margin-bottom:10px;">Your Answers:</h4>
        <div style="display: flex; justify-content: center; gap: 20px; flex-wrap: wrap;">
          ${['A', 'B', 'C', 'D'].map(opt => {
            let btnClass = 'optBtn';
            if (studentAnswer === opt && correctAnswer === opt) {
              btnClass += ' correct';
            } else if (studentAnswer === opt && studentAnswer !== correctAnswer) {
              btnClass += ' wrong';
            } else if (correctAnswer === opt) {
              btnClass += ' correct';
            } else if (studentAnswer === null) {
              btnClass += ' not-attempted';
            }
            return `<button class="${btnClass}" style="margin:5px;">${opt}</button>`;
          }).join('')}
        </div>
        <div style="margin-top:15px; font-weight:bold;">
          ${studentAnswer ? 
            `<span class="${studentAnswer === correctAnswer ? 'correct-answer' : 'wrong-answer'}">
              Your Answer: ${studentAnswer} 
              ${studentAnswer !== correctAnswer ? ` | Correct Answer: ${correctAnswer}` : ''}
            </span>` :
            `<span class="not-attempted">Not Attempted | Correct Answer: ${correctAnswer}</span>`
          }
        </div>
      </div>
    `;
    
    container.appendChild(questionDiv);
  });
}

// Event listeners for navigation
document.getElementById('closeSummaryBtn').onclick = () => {
  window.close();
};

document.getElementById('closeReviewBtn').onclick = () => {
  window.close();
};

// Initialize when page loads
document.addEventListener('DOMContentLoaded', function() {
    setupKeyboardNavigation();
    setupModalKeyboardSupport();
    
    // Auto-convert section to uppercase
    document.getElementById('stuSection').addEventListener('input', function() {
        this.value = this.value.toUpperCase();
    });
    
    // Show pending form results if any
    showPendingFormResults();
    
    // Show data recovery dashboard if admin
    showDataRecoveryDashboard();
    
    // Initialize network status
    if (!navigator.onLine) {
        document.getElementById('networkStatus').style.display = 'block';
    }
    
    // Clean duplicate data on startup
    const cleanedCount = cleanDuplicateStudentData();
    if (cleanedCount > 0) {
        console.log(`üßπ Cleaned ${cleanedCount} duplicate entries on startup`);
    }
});
</script>
</body>
</html>
