<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>LFJC ONLINE EXAMINATION</title>
<style>
/* ===== BASE STYLES ===== */
:root {
  --primary-color: #4B0082;
  --secondary-color: #D8BFD8;
  --light-purple: #E6E6FA;
  --white: #fff;
  --black: #000;
  --success: #32CD32;
  --warning: #ff9900;
  --danger: #ff6666;
  --shadow: 0 5px 15px rgba(0,0,0,0.1);
  --transition: all 0.3s ease;
}

* {
  box-sizing: border-box;
}

body {
  font-family: "SF Pro Display", Arial, sans-serif;
  margin: 0;
  background: var(--white);
  color: var(--black);
  line-height: 1.6;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

/* Disable right-click context menu */
body {
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

/* Enhanced Screenshot protection */
#screenshotProtection {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: transparent;
  z-index: 2147483647;
  pointer-events: none;
}

.screenshot-dots {
  position: absolute;
  width: 100%;
  height: 100%;
  background: 
    radial-gradient(circle at 10% 20%, rgba(255,255,255,0.02) 1px, transparent 1px),
    radial-gradient(circle at 30% 40%, rgba(255,255,255,0.02) 1px, transparent 1px),
    radial-gradient(circle at 50% 60%, rgba(255,255,255,0.02) 1px, transparent 1px),
    radial-gradient(circle at 70% 80%, rgba(255,255,255,0.02) 1px, transparent 1px),
    radial-gradient(circle at 90% 10%, rgba(255,255,255,0.02) 1px, transparent 1px);
  background-size: 200px 200px;
  animation: flicker 0.5s infinite;
}

@keyframes flicker {
  0%, 100% { opacity: 0.8; }
  50% { opacity: 0.9; }
}

/* Additional screenshot protection */
#screenshotBlock {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: transparent;
  z-index: 2147483646;
  pointer-events: none;
}

/* ===== HEADER & FOOTER ===== */
header {
  background: linear-gradient(145deg, var(--light-purple), var(--secondary-color));
  color: var(--primary-color);
  text-align: center;
  padding: 20px;
  font-size: 36px;
  font-weight: 700;
  letter-spacing: 1.5px;
  box-shadow: var(--shadow);
  text-shadow: 0 1px 2px var(--white);
}

footer {
  background: var(--light-purple);
  color: var(--primary-color);
  padding: 10px;
  text-align: center;
  font-weight: bold;
  position: fixed;
  width: 100%;
  bottom: 0;
}

/* ===== STUDENT ENTRY SECTION ===== */
#studentEntry {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  min-height: calc(100vh - 140px);
  padding: 16px;
  text-align: center;
}

.form-group {
  display: flex;
  flex-direction: row;
  align-items: center;
  justify-content: center;
  margin-bottom: 60px;
  width: 100%;
  max-width: 500px;
}

.form-group label {
  font-size: 1.15rem;
  font-weight: 600;
  margin-right: 10px;
  color: var(--primary-color);
  width: 180px;
  text-align: right;
}

input[type="text"] {
  padding: 12px 14px;
  font-size: 1.1rem;
  border-radius: 10px;
  border: 1.5px solid var(--primary-color);
  outline: none;
  min-width: 250px;
  transition: var(--transition);
  text-transform: uppercase;
}

input[type="text"]:focus {
  border-color: var(--primary-color);
  box-shadow: 0 0 0 3px rgba(75, 0, 130, 0.2);
}

input.error {
  animation: glowRed 0.5s alternate infinite;
  border-color: var(--danger);
  background-color: #ffe6e6;
}

@keyframes glowRed {
  0% { box-shadow: 0 0 5px var(--danger); }
  100% { box-shadow: 0 0 15px var(--danger); }
}

/* ===== BUTTON STYLES ===== */
button {
  position: relative;
  overflow: hidden;
  cursor: pointer;
  border: none;
  border-radius: 12px;
  transition: var(--transition);
  box-shadow: 0 6px #aaa;
  background: linear-gradient(to bottom, #fafaff, #dcd6f7);
  color: var(--primary-color);
  font-weight: 600;
  padding: 12px 24px;
  font-size: 18px;
}

button:hover {
  transform: translateY(-2px);
  box-shadow: 0 8px 15px rgba(0,0,0,.28);
}

button:active {
  transform: translateY(3px) scale(.98);
}

button:focus {
  outline: 2px solid var(--primary-color);
  outline-offset: 2px;
}

.optBtn {
  font-size: 16px;
  padding: 8px 18px;
  margin: 6px;
  border: 2px solid var(--primary-color);
  background: var(--white);
  border-radius: 8px;
  box-shadow: 0 5px #aaa;
}

.optBtn.selected {
  background: var(--success);
  color: var(--white);
  border-color: #2fa92f;
}

.optBtn.correct {
  background: #32CD32;
  color: white;
  border-color: #228B22;
}

.optBtn.wrong {
  background: #FF6B6B;
  color: white;
  border-color: #DC143C;
}

.optBtn.not-attempted {
  background: #B0B0B0;
  color: white;
  border-color: #808080;
}

.navBtn {
  font-size: 16px;
  padding: 10px 20px;
  border-radius: 8px;
  color: var(--white);
  font-weight: bold;
  cursor: pointer;
  background: linear-gradient(145deg, #1E90FF, #4682B4);
  margin: 0 15px;
}

#markReviewBtn {
  background: linear-gradient(145deg, #ffb84d, var(--warning));
}

#markReviewBtn.reviewed {
  background: linear-gradient(145deg, #ffd700, #ffcc00) !important;
  color: var(--black);
}

#submitBtn {
  background: linear-gradient(145deg, #c8b88a, #b49e60);
}

/* ===== TIMER STYLES ===== */
#timerEl {
  font-size: 20px;
  font-weight: bold;
  color: var(--primary-color);
  padding: 6px 12px;
  border-radius: 6px;
  background: #f0f0ff;
  display: inline-block;
  transition: var(--transition);
}

#timerEl.blink {
  animation: blinkTimer 1s infinite;
}

#timerEl.blink-line {
  animation: blinkLineAnim 1s infinite;
}

@keyframes blinkTimer {
  0% { background: var(--danger); color: var(--white); }
  50% { background: var(--white); color: var(--primary-color); }
  100% { background: var(--danger); color: var(--white); }
}

@keyframes blinkLineAnim {
  0% { background: #ffcccc; }
  50% { background: var(--white); }
  100% { background: #ffcccc; }
}

/* ===== PALETTE STYLES ===== */
#paletteContainer {
  display: grid;
  gap: 8px;
  margin: 20px auto;
  max-width: 100%;
  padding: 0 10px;
  justify-content: center;
}

#paletteContainer button {
  width: 40px;
  height: 40px;
  border-radius: 50%;
  font-size: 14px;
  margin: 2px;
  border: 1px solid var(--primary-color);
  background: var(--light-purple);
  color: var(--primary-color);
  display: flex;
  align-items: center;
  justify-content: center;
}

#paletteContainer button.selected {
  background: var(--success);
  color: var(--white);
  border-color: #2fa92f;
}

#paletteContainer button.reviewed {
  background: yellow;
  color: var(--black);
}

#paletteContainer button.current {
  border: 3px solid red;
}

#paletteContainer button.correct-answer {
  background: #32CD32;
  color: white;
}

#paletteContainer button.wrong-answer {
  background: #FF6B6B;
  color: white;
}

#paletteContainer button.not-attempted-answer {
  background: #B0B0B0;
  color: white;
}

/* ===== EXAM AREA STYLES ===== */
#examArea {
  padding: 16px;
  text-align: center;
  display: none;
}

#examHeader {
  display: flex;
  align-items: center;
  width: 100%;
  font-weight: bold;
  margin-bottom: 20px;
}

#stuInfo {
  flex: 0 0 auto;
  text-align: left;
  white-space: nowrap;
}

#stuQInfo {
  flex: 1;
  text-align: center;
  white-space: nowrap;
  font-size: 18px;
  font-weight: bold;
  color: var(--primary-color);
}

.sectionTitle {
  font-size: 22px;
  color: var(--primary-color);
  font-weight: bold;
  margin-bottom: 8px;
}

img.questionImg {
  max-width: 95vw;
  width: auto;
  height: auto;
  border-radius: 10px;
  -webkit-user-drag: none;
  -khtml-user-drag: none;
  -moz-user-drag: none;
  -o-user-drag: none;
  user-drag: none;
  display: block;
  margin-left: auto;
  margin-right: auto;
  transition: opacity 0.3s ease;
}

/* ===== ANIMATIONS ===== */
.glow {
  animation: glowPulse 1.6s infinite alternate;
  box-shadow: 0 8px 18px rgba(75,0,130,0.12);
}

@keyframes glowPulse {
  0% { box-shadow: 0 6px 10px rgba(75,0,130,0.06); transform: translateY(0); }
  50% { box-shadow: 0 12px 30px rgba(75,0,130,0.14); transform: translateY(-2px); }
  100% { box-shadow: 0 6px 10px rgba(75,0,130,0.06); transform: translateY(0); }
}

/* ===== SECURITY OVERLAY STYLES ===== */
#fullRedOverlay {
  position: fixed;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  display: none;
  background: red;
  z-index: 9999;
  pointer-events: auto;
}

#accessDeniedBox {
  position: fixed;
  left: 50%;
  top: 40%;
  transform: translate(-50%, -50%);
  z-index: 10000;
  color: var(--white);
  text-align: center;
  display: none;
  pointer-events: auto;
}

#accessDeniedBox h1 {
  font-size: 48px;
  font-weight: 900;
  margin: 0 0 18px 0;
  color: var(--white);
  text-shadow: 0 2px 6px rgba(0,0,0,0.4);
}

#callAdminBtn {
  padding: 12px 22px;
  border-radius: 12px;
  font-weight: 800;
}

/* ===== MODAL STYLES ===== */
.confirmModal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0,0,0,0.45);
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 10001;
}

.confirmBox {
  background: var(--white);
  padding: 20px;
  border-radius: 12px;
  min-width: 280px;
  text-align: center;
  box-shadow: 0 5px 15px rgba(0,0,0,0.3);
}

.confirmBox p {
  font-size: 18px;
  color: var(--primary-color);
  margin-bottom: 15px;
}

.confirmBox button {
  margin: 0 10px;
  padding: 8px 16px;
  font-size: 16px;
  cursor: pointer;
}

#adminPassModal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0,0,0,0.6);
  display: none;
  justify-content: center;
  align-items: center;
  z-index: 20000;
}

#adminPassBox {
  background: var(--white);
  padding: 20px;
  text-align: center;
  width: 260px;
  border-radius: 12px;
}

#adminPassBox input {
  width: 90%;
  padding: 10px;
  border: 1px solid var(--primary-color);
  border-radius: 8px;
  margin-bottom: 10px;
}

/* ===== FONT SIZE ADJUSTMENTS ===== */
#stuInfo, #stuQInfo, #timerEl {
  font-size: 20px !important;
}

/* Increase table row height vertically */
table td, table th {
  padding-top: 20px;
  padding-bottom: 20px;
}

/* ===== RESPONSIVE STYLES ===== */
@media (max-width: 600px) {
  #accessDeniedBox h1 {
    font-size: 28px;
  }
  
  #callAdminBtn {
    padding: 10px 14px;
  }
  
  .form-group {
    flex-direction: column;
    align-items: flex-start;
  }
  
  .form-group label {
    text-align: left;
    width: auto;
    margin-bottom: 5px;
  }
  
  #examHeader {
    flex-direction: column;
    gap: 10px;
  }
  
  #stuInfo, #stuQInfo {
    text-align: center;
  }
  
  .navContainer {
    flex-direction: column;
    align-items: center;
  }
  
  .navBtn {
    width: 80%;
    margin-bottom: 10px;
    margin-left: 0;
    margin-right: 0;
  }
  
  #paletteContainer {
    grid-template-columns: repeat(5, 1fr) !important;
    gap: 6px;
  }
  
  #paletteContainer button {
    width: 35px;
    height: 35px;
    font-size: 12px;
  }
}

@media (min-width: 601px) and (max-width: 900px) {
  #paletteContainer {
    grid-template-columns: repeat(10, 1fr) !important;
  }
}

@media (min-width: 901px) and (max-width: 1200px) {
  #paletteContainer {
    grid-template-columns: repeat(15, 1fr) !important;
  }
}

@media (min-width: 1201px) {
  #paletteContainer {
    grid-template-columns: repeat(20, 1fr) !important;
  }
}

/* ===== ERROR MESSAGE STYLES ===== */
.error-message {
  color: #ff3333;
  font-weight: 600;
  padding: 10px;
  margin: 10px 0;
  border-radius: 6px;
  background: rgba(255, 102, 102, 0.1);
  border: 1px solid #ff6666;
  animation: blinkRed 1s infinite;
}

@keyframes blinkRed {
  0% { opacity: 1; }
  50% { opacity: 0.6; }
  100% { opacity: 1; }
}

/* ===== RESULTS TABLE STYLES ===== */
.results-table {
  width: 100%;
  max-width: 900px;
  margin: 20px auto;
  border-collapse: collapse;
  font-size: 18px;
  text-align: center;
}

.results-table th {
  background: #E6E6FA;
  padding: 15px;
  border: 1px solid var(--primary-color);
}

.results-table td {
  padding: 15px;
  border: 1px solid var(--primary-color);
}

.results-table tr:nth-child(even) {
  background: #f9f9f9;
}

.results-table tr:hover {
  background: #f0f0ff;
}

/* ===== REVIEW MODE STYLES ===== */
.answer-status {
  margin: 10px 0;
  padding: 10px;
  border-radius: 8px;
  font-weight: bold;
}

.answer-status.correct {
  background: #d4edda;
  color: #155724;
  border: 1px solid #c3e6cb;
}

.answer-status.wrong {
  background: #f8d7da;
  color: #721c24;
  border: 1px solid #f5c6cb;
}

.answer-status.not-attempted {
  background: #e2e3e5;
  color: #383d41;
  border: 1px solid #d6d8db;
}

.correct-answer {
  color: #155724;
  font-weight: bold;
}

.wrong-answer {
  color: #721c24;
  font-weight: bold;
}

/* ===== AREA STYLES ===== */
#summaryArea, #reviewArea {
  display: none;
  padding: 20px;
}

.area-header {
  text-align: center;
  margin-bottom: 30px;
}

.area-header h2 {
  color: #4B0082;
  margin-bottom: 10px;
}

/* ===== VERTICAL GAP STYLES ===== */
.options-container {
  margin-bottom: 60px;
}

.navContainer {
  margin-top: 40px;
  display: flex;
  justify-content: center;
  gap: 20px;
  flex-wrap: wrap;
}

/* ===== SECURITY MESSAGE STYLES ===== */
.security-message {
  background: #fff3cd;
  border: 1px solid #ffeaa7;
  color: #856404;
  padding: 15px;
  border-radius: 8px;
  margin: 20px 0;
  text-align: center;
  font-weight: bold;
}

/* ===== AUTO TRANSITION STYLES ===== */
.auto-transition-message {
  background: #d4edda;
  border: 1px solid #c3e6cb;
  color: #155724;
  padding: 15px;
  border-radius: 8px;
  margin: 20px 0;
  text-align: center;
  font-weight: bold;
  animation: pulse 2s infinite;
}

@keyframes pulse {
  0% { transform: scale(1); }
  50% { transform: scale(1.02); }
  100% { transform: scale(1); }
}

.waiting-message {
  background: #d1ecf1;
  border: 1px solid #bee5eb;
  color: #0c5460;
  padding: 20px;
  border-radius: 8px;
  margin: 30px 0;
  text-align: center;
  font-weight: bold;
  font-size: 18px;
}

.waiting-timer {
  font-size: 24px;
  font-weight: bold;
  color: #4B0082;
  margin: 10px 0;
}

/* ===== LOADING STYLES ===== */
.loading-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 40px;
  text-align: center;
}

.spinner {
  border: 5px solid #f3f3f3;
  border-top: 5px solid #4B0082;
  border-radius: 50%;
  width: 50px;
  height: 50px;
  animation: spin 1s linear infinite;
  margin-bottom: 20px;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

/* ===== WARNING BANNER STYLES ===== */
.warning-banner {
  background: #ffcccc;
  color: #721c24;
  padding: 15px;
  text-align: center;
  font-weight: bold;
  border: 1px solid #f5c6cb;
  border-radius: 8px;
  margin: 20px 0;
}

/* ===== IMAGE ERROR STYLES ===== */
.image-error {
  background: #ffebee;
  border: 2px solid #ffcdd2;
  color: #c62828;
  padding: 20px;
  border-radius: 8px;
  margin: 20px 0;
  text-align: center;
  font-weight: bold;
}

.image-error h3 {
  margin: 0 0 10px 0;
  color: #c62828;
}

.loading-message {
  background: #e3f2fd;
  border: 2px solid #bbdefb;
  color: #1565c0;
  padding: 15px;
  border-radius: 8px;
  margin: 10px 0;
  text-align: center;
  font-weight: bold;
}

/* ===== SUCCESS MESSAGE STYLES ===== */
.success-message {
  background: #d4edda;
  color: #155724;
  padding: 20px;
  border-radius: 8px;
  margin: 20px 0;
  text-align: center;
  font-weight: bold;
  border: 1px solid #c3e6cb;
}

.success-message h3 {
  margin: 0 0 10px 0;
  color: #155724;
}

/* ===== SMOOTH TRANSITION STYLES ===== */
.question-transition {
  transition: all 0.3s ease-in-out;
}

.question-fade-in {
  animation: fadeIn 0.3s ease-in-out;
}

@keyframes fadeIn {
  from { opacity: 0; transform: translateY(10px); }
  to { opacity: 1; transform: translateY(0); }
}

/* ===== PRELOADING STYLES ===== */
.preload-image {
  position: absolute;
  left: -9999px;
  top: -9999px;
  opacity: 0;
}

/* ===== DETAILED RESULTS TABLE STYLES ===== */
.detailed-results-table {
  width: 100%;
  max-width: 900px;
  margin: 30px auto;
  border-collapse: collapse;
  font-size: 18px;
  text-align: center;
  box-shadow: 0 4px 8px rgba(0,0,0,0.1);
}

.detailed-results-table th {
  background: #4B0082;
  color: white;
  padding: 18px;
  border: 1px solid var(--primary-color);
  font-weight: bold;
}

.detailed-results-table td {
  padding: 18px;
  border: 1px solid var(--primary-color);
}

.detailed-results-table tr:nth-child(even) {
  background: #f8f6ff;
}

.detailed-results-table tr:hover {
  background: #f0f0ff;
  transform: scale(1.01);
  transition: transform 0.2s ease;
}

.detailed-results-table .total-row {
  background: #E6E6FA !important;
  font-weight: bold;
  font-size: 20px;
}

.detailed-results-table .highlight {
  background: #d4edda;
  font-weight: bold;
}

/* ===== FORM ASSIGNMENT STYLES ===== */
.form-assignment {
  background: #e8f4fd;
  border: 2px solid #4B0082;
  border-radius: 10px;
  padding: 15px;
  margin: 15px 0;
  text-align: center;
}

.form-assignment h3 {
  color: #4B0082;
  margin: 0 0 10px 0;
}

.assigned-form {
  font-size: 24px;
  font-weight: bold;
  color: #4B0082;
  background: white;
  padding: 10px 20px;
  border-radius: 8px;
  display: inline-block;
  margin: 10px 0;
}

/* ===== SECURITY WARNING STYLES ===== */
.security-warning {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  background: linear-gradient(145deg, #ff6b6b, #dc143c);
  color: white;
  text-align: center;
  padding: 15px;
  font-weight: bold;
  z-index: 10000;
  box-shadow: 0 4px 12px rgba(0,0,0,0.3);
  animation: pulseWarning 2s infinite;
}

@keyframes pulseWarning {
  0% { opacity: 1; }
  50% { opacity: 0.8; }
  100% { opacity: 1; }
}

.network-status {
  position: fixed;
  bottom: 10px;
  right: 10px;
  padding: 8px 12px;
  border-radius: 20px;
  font-size: 12px;
  font-weight: bold;
  z-index: 9999;
}

.network-online {
  background: var(--success);
  color: white;
}

.network-offline {
  background: var(--warning);
  color: white;
  animation: blinkOffline 1s infinite;
}

@keyframes blinkOffline {
  0%, 50% { opacity: 1; }
  51%, 100% { opacity: 0.5; }
}

/* ===== TERMINATION SCREEN STYLES ===== */
.termination-screen {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: linear-gradient(145deg, #ff6b6b, #dc143c);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 10000;
  color: white;
  text-align: center;
}

.termination-content {
  background: rgba(0,0,0,0.9);
  padding: 40px;
  border-radius: 15px;
  max-width: 600px;
  box-shadow: 0 10px 30px rgba(0,0,0,0.5);
}

/* ===== DATA INTEGRITY STYLES ===== */
.data-integrity-check {
  background: #e8f5e8;
  border: 2px solid #4CAF50;
  border-radius: 8px;
  padding: 15px;
  margin: 15px 0;
  text-align: center;
}

.duplicate-warning {
  background: #fff3cd;
  border: 2px solid #ffc107;
  border-radius: 8px;
  padding: 15px;
  margin: 15px 0;
  text-align: center;
  font-weight: bold;
}

/* ===== SUBJECT DISPLAY STYLES ===== */
.subject-display {
  background: linear-gradient(145deg, #4B0082, #6A0DAD);
  color: white;
  padding: 10px 20px;
  border-radius: 8px;
  font-weight: bold;
  margin: 10px 0;
  display: inline-block;
  box-shadow: 0 4px 8px rgba(0,0,0,0.2);
}

.current-subject {
  font-size: 18px;
  text-align: center;
  margin: 15px 0;
  padding: 10px;
  background: #f0f0ff;
  border-radius: 8px;
  border-left: 4px solid #4B0082;
}

/* ===== ACCESS DENIED STYLES ===== */
.access-denied-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: #ff0000;
  z-index: 99999;
  display: flex;
  justify-content: center;
  align-items: center;
  color: white;
  text-align: center;
}

.access-denied-content {
  background: rgba(0,0,0,0.9);
  padding: 40px;
  border-radius: 15px;
  max-width: 500px;
}

.access-denied-content h1 {
  font-size: 48px;
  margin-bottom: 20px;
  color: #ff6b6b;
}

.access-denied-content p {
  font-size: 18px;
  margin-bottom: 30px;
}

/* ===== TAB SWITCH WARNING STYLES ===== */
.tab-switch-warning {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(255, 0, 0, 0.9);
  z-index: 100000;
  display: flex;
  justify-content: center;
  align-items: center;
  color: white;
  text-align: center;
}

.tab-switch-content {
  background: rgba(0,0,0,0.9);
  padding: 40px;
  border-radius: 15px;
  max-width: 500px;
}

.tab-switch-content h1 {
  font-size: 36px;
  margin-bottom: 20px;
  color: #ff6b6b;
}

.tab-switch-content p {
  font-size: 18px;
  margin-bottom: 30px;
}

/* ===== ENHANCED NETWORK STATUS STYLES ===== */
#enhancedNetworkStatus {
  position: fixed;
  top: 10px;
  right: 10px;
  padding: 10px;
  border-radius: 5px;
  z-index: 10000;
  font-weight: bold;
  display: none;
  box-shadow: 0 2px 10px rgba(0,0,0,0.3);
  min-width: 200px;
}

.network-quality-indicator {
  font-size: 12px;
  margin-top: 5px;
  opacity: 0.8;
}

/* ===== OFFLINE BACKUP STYLES ===== */
.offline-backup-notification {
  position: fixed;
  bottom: 60px;
  left: 50%;
  transform: translateX(-50%);
  background: #ff9900;
  color: white;
  padding: 15px 20px;
  border-radius: 8px;
  z-index: 9999;
  text-align: center;
  box-shadow: 0 4px 12px rgba(0,0,0,0.3);
  animation: slideUp 0.3s ease;
}

@keyframes slideUp {
  from { transform: translate(-50%, 100%); opacity: 0; }
  to { transform: translate(-50%, 0); opacity: 1; }
}

/* ===== RECOVERY NOTIFICATION STYLES ===== */
.recovery-notification {
  position: fixed;
  top: 20px;
  left: 50%;
  transform: translateX(-50%);
  background: #4CAF50;
  color: white;
  padding: 15px 20px;
  border-radius: 8px;
  z-index: 9999;
  text-align: center;
  box-shadow: 0 4px 12px rgba(0,0,0,0.3);
}
</style>
</head>

<body>

<header>LFJC ONLINE EXAMINATION</header>

<div id="studentEntry">
  <div class="warning-banner" id="examWarning" style="display:none;">
    <p>‚ö†Ô∏è WARNING: Exam in progress. Do not refresh or close this window!</p>
  </div>
  
  <div class="form-group"><label>NAME</label><input type="text" id="stuName" placeholder="Only letters & spaces" autocomplete="off"></div>
  <div class="form-group"><label>SECTION</label><input type="text" id="stuSection" placeholder="Letters & digits" autocomplete="off"></div>
  <div class="form-group"><label>ROLL NUMBER</label><input type="text" id="stuRoll" placeholder="Digits only" autocomplete="off"></div>
  <div class="form-group"><label>ADMISSION NUMBER</label><input type="text" id="stuAdm" placeholder="Digits only" autocomplete="off"></div>
  
  <div class="form-group"><button id="stuStartBtn" style="display:none;">Start Exam</button></div>
  <p id="studentMsg"></p>
  <div id="errorMessages"></div>
  
  <div id="resumeExamSection" style="display:none; margin-top: 20px;">
    <div class="security-message">
      <p>You have an exam in progress. Would you like to resume?</p>
      <button id="resumeExamBtn" class="navBtn">Resume Exam</button>
    </div>
  </div>

  <!-- Duplicate Submission Warning -->
  <div id="duplicateWarning" class="duplicate-warning" style="display:none;">
    <h3>‚ö†Ô∏è Previous Submission Detected</h3>
    <p>It appears you have already submitted an exam. Starting a new exam will create a duplicate entry.</p>
    <button id="forceStartBtn" class="navBtn" style="background:linear-gradient(145deg, #dc3545, #c82333);">Start New Exam Anyway</button>
  </div>
</div>

<div id="examArea" style="display:none;">
  <div id="examHeader" style="display:flex;align-items:center;width:100%;font-weight:bold;">
    <div id="stuInfo" style="flex:0 0 auto;text-align:left; white-space:nowrap;"></div>
    <div id="stuQInfo" style="flex:1;text-align:center; white-space:nowrap;"></div>
    <div style="flex:0 0 auto;text-align:right; white-space:nowrap;">
        <span id="timerEl">üïí 00:00</span>
    </div>
  </div>

  <div id="questionContainer" style="text-align:center;margin-top:10px;"></div>

  <div class="navContainer">
    <button class="navBtn" id="prevBtn">‚¨Ö Previous</button>
    <button class="navBtn" id="markReviewBtn">Mark Review</button>
    <button class="navBtn" id="nextBtn">Next ‚û°</button>
    <button class="navBtn" id="submitBtn">Submit Exam</button>
  </div>

  <div id="paletteContainer"></div>
</div>

<!-- Summary Area -->
<div id="summaryArea">
  <div class="area-header">
    <h2>üìä Exam Summary - <span id="summaryStudentName"></span></h2>
    <div>
      <b>Section:</b> <span id="summarySection"></span> | 
      <b>Roll:</b> <span id="summaryRoll"></span> | 
      <b>Admission No:</b> <span id="summaryAdm"></span> |
      <b>Form:</b> <span id="summaryForm"></span>
    </div>
  </div>
  
  <div id="summaryTableContainer" style="overflow-x:auto;display:flex;justify-content:center;width:100%;"></div>
  
  <div style="text-align:center; margin:30px 0;">
    <div id="waitingMessage" class="waiting-message">
      <div>‚è≥ Waiting for Exam Time to Complete</div>
      <div class="waiting-timer" id="waitingTimer">00:00</div>
      <div>Detailed solutions will be available automatically when the exam time is over.</div>
    </div>
    <div id="autoTransitionMessage" class="auto-transition-message" style="display:none;">
      üîÑ Auto-transitioning to detailed solutions in <span id="countdown">5</span> seconds...
    </div>
    <button id="closeSummaryBtn" class="navBtn" style="background:linear-gradient(145deg, #dc3545, #c82333);">Close</button>
  </div>
</div>

<!-- Review Area -->
<div id="reviewArea">
  <div class="area-header">
    <h2>üìù Detailed Solutions - <span id="reviewStudentName"></span></h2>
    <div>
      <b>Section:</b> <span id="reviewSection"></span> | 
      <b>Roll:</b> <span id="reviewRoll"></span> | 
      <b>Admission No:</b> <span id="reviewAdm"></span> |
      <b>Form:</b> <span id="reviewForm"></span>
    </div>
  </div>
  
  <!-- Results Table in Detailed Solutions -->
  <div id="detailedResultsContainer" style="overflow-x:auto;display:flex;justify-content:center;width:100%;margin:30px 0;"></div>
  
  <div id="reviewQuestionsContainer"></div>
  
  <div style="text-align:center; margin:30px 0;">
    <button id="closeReviewBtn" class="navBtn" style="background:linear-gradient(145deg, #dc3545, #c82333);">Close</button>
  </div>
</div>

<footer>LFJC@2025 All rights reserved - 10 Form System</footer>

<div id="fullRedOverlay"></div>
<div id="accessDeniedBox">
  <h1>ACCESS DENIED</h1>
  <button id="callAdminBtn" class="glow">Enter Password</button>
</div>

<div class="confirmModal" id="confirmModal">
  <div class="confirmBox">
    <p id="confirmText">Confirm?</p>
    <button id="confirmYes">Yes</button>
    <button id="confirmNo">No</button>
  </div>
</div>

<div id="adminPassModal">
  <div id="adminPassBox">
    <h3>Enter Admin Password</h3>
    <input type="password" id="adminPassInput">
    <br><br>
    <button id="adminPassSubmit">Submit</button>
  </div>
</div>

<!-- Enhanced Screenshot Protection -->
<div id="screenshotProtection">
  <div class="screenshot-dots"></div>
</div>
<div id="screenshotBlock"></div>

<!-- Access Denied Overlay -->
<div id="accessDeniedOverlay" class="access-denied-overlay" style="display:none;">
  <div class="access-denied-content">
    <h1>üö´ ACCESS DENIED</h1>
    <p>You have already taken an exam within the last 24 hours.</p>
    <p>Please contact administrator for assistance.</p>
    <div style="margin-top: 30px;">
      <input type="password" id="adminOverridePass" placeholder="Enter Admin Password" style="padding: 10px; width: 200px; border-radius: 5px; border: none;">
      <button id="adminOverrideBtn" style="padding: 10px 20px; margin-left: 10px; background: #4B0082; color: white; border: none; border-radius: 5px; cursor: pointer;">Submit</button>
    </div>
  </div>
</div>

<!-- Tab Switch Warning -->
<div id="tabSwitchWarning" class="tab-switch-warning" style="display:none;">
  <div class="tab-switch-content">
    <h1>üö´ EXAM VIOLATION DETECTED</h1>
    <p>You have switched tabs/windows during the exam.</p>
    <p>Your exam will be automatically submitted now.</p>
    <div id="tabSwitchCountdown" style="font-size: 24px; font-weight: bold; margin: 20px 0;">Submitting in 5 seconds...</div>
  </div>
</div>

<script>
// ===== CONFIGURATION =====
const MARK_PER_CORRECT = 4, MARK_PER_WRONG = -1;
const EXAM_DURATION_MINUTES = 1; // 5 minutes for testing
const EXAM_DURATION_MS = EXAM_DURATION_MINUTES * 60 * 1000;
const STORAGE_KEY_PREFIX = "lfjc_exam_";
const MAX_QUESTIONS = 60; // Maximum expected questions
const ADMIN_PASSWORD = "lfjc2025"; // Admin password for override
const COOLDOWN_HOURS = 24; // 24-hour cooldown period

// ===== 10-FORM CONFIGURATION =====
const GOOGLE_FORMS = {
    'A': "https://docs.google.com/forms/d/e/1FAIpQLSe4uuphhY4-p5jdTZqxG_ZZUKAhQZF1ytyNizPXb0n3L85JIw/formResponse",
    'B': "https://docs.google.com/forms/d/e/1FAIpQLSc3JIcnUysvUtH12QWpHG9wAF4vd1NgEYqeyHwNP0UEkPqi5w/formResponse", 
    'C': "https://docs.google.com/forms/d/e/1FAIpQLScqYdTGoD4l0jJvzYw0tdBNRSMPepnGtOOowOXYwDFov43KHg/formResponse",
    'D': "https://docs.google.com/forms/d/e/1FAIpQLSfjAyDlY-5BAF5rPvzQS0AeTI6Vs2Rkri0V6_miA0mRivZAEg/formResponse",
    'E': "https://docs.google.com/forms/d/e/1FAIpQLSfK6Skl6Uxj8VyGnhhqfdPHcJ8mbcgpzIKLpWFElzdeQSKMgA/formResponse",
    'F': "https://docs.google.com/forms/d/e/1FAIpQLSeP-Gx2XnUg_Q17asOOeYzkoGtLykVIcQ2W006YTqTpE7xY6g/formResponse",
    'G': "https://docs.google.com/forms/d/e/1FAIpQLSe1vg_I5XR3ljr-UNFi-MXxUgjdTDyrVbHxqi_dkvtmYGUTEA/formResponse",
    'H': "https://docs.google.com/forms/d/e/1FAIpQLScyv8cps4StN2UXrsXqNdLu5UBR7t0Vwk8WSnynU2tvracs1g/formResponse",
    'I': "https://docs.google.com/forms/d/e/1FAIpQLSeyen2hSdhRwztpWnH6lyuL91ZROqwDMKIaa4gN_e-Xvyvb_g/formResponse",
    'J': "https://docs.google.com/forms/d/e/1FAIpQLSelbDi1n1EKWu7G0I92hTML6vWUO2c55p2dqrEOQ7cWflaSNg/formResponse"
};

// DYNAMIC STUDENT DISTRIBUTION - CHANGE THIS NUMBER FOR DIFFERENT CLASS SIZES
const TOTAL_STUDENTS = 150; // Set this to 100, 150, 200, etc.

// Form field mappings - FROM YOUR PRE-FILL URL
const FORM_FIELDS = {
    STUDENT_NAME: "entry.217666919",
    SECTION: "entry.2006392966",
    ROLL_NUMBER: "entry.547275105",
    ADMISSION_NUMBER: "entry.1234063852",
    MATHS_MARKS: "entry.1989859216",
    PHYSICS_MARKS: "entry.1953974928",
    CHEMISTRY_MARKS: "entry.296331194",
    TOTAL_MARKS: "entry.1289040887",
    TIMESTAMP: "entry.2139100252"
};

// ===== GLOBAL VARIABLES =====
let images = [];
let answerKey = [];
let keyLoaded = false;
let hasSubmitted = false;
let examStartTime = null;
let waitingTimerInterval = null;
let autoTransitionTimer = null;
let examInProgress = false;
let preloadedImages = {}; // Cache for preloaded images
let currentSubjData = null; // Store subject data for detailed solutions
let assignedForm = 'A'; // Default form assignment
let tabSwitchDetected = false;
let tabSwitchTimeout = null;

const subjects = ["Maths", "Physics", "Chemistry"];

let examData = {files: [], subjectNames: [], keys: [], originalOrder: []};
let progress = null, timerInterval = null;

// ===== ENHANCED NETWORK FAILURE COVERAGE SYSTEMS =====

class NetworkManager {
    constructor() {
        this.isOnline = navigator.onLine;
        this.offlineSubmissions = JSON.parse(localStorage.getItem('offline_submissions') || '[]');
        this.recoveryAttempts = 0;
        this.networkQuality = 'good';
        this.setupNetworkListeners();
    }
    
    setupNetworkListeners() {
        window.addEventListener('online', () => this.handleConnectionRestored());
        window.addEventListener('offline', () => this.handleConnectionLost());
        
        // Periodic network quality check
        setInterval(() => this.checkNetworkQuality(), 30000);
        
        // Monitor submission queue
        setInterval(() => this.processOfflineBacklog(), 60000);
    }
    
    async checkNetworkQuality() {
        if (!navigator.onLine) {
            this.networkQuality = 'offline';
            this.updateNetworkStatusDisplay();
            return;
        }
        
        try {
            const startTime = Date.now();
            const response = await fetch('https://www.gstatic.com/generate_204', { 
                method: 'GET',
                cache: 'no-cache',
                signal: AbortSignal.timeout(5000)
            });
            const latency = Date.now() - startTime;
            
            if (latency < 1000) {
                this.networkQuality = 'good';
            } else if (latency < 3000) {
                this.networkQuality = 'fair';
            } else {
                this.networkQuality = 'poor';
            }
        } catch (error) {
            this.networkQuality = 'offline';
        }
        
        this.updateNetworkStatusDisplay();
    }
    
    handleConnectionLost() {
        if (this.isOnline) {
            console.warn('üåê Network connection lost');
            this.isOnline = false;
            this.networkQuality = 'offline';
            this.showNetworkWarning();
            this.activateOfflineMode();
        }
    }
    
    async handleConnectionRestored() {
        console.log('üåê Network connection restored');
        this.isOnline = true;
        this.hideNetworkWarning();
        this.showRecoveryNotification('Connection restored - syncing data...');
        
        // Wait a moment for stable connection
        await new Promise(resolve => setTimeout(resolve, 2000));
        
        // Process backlog
        await this.processOfflineBacklog();
        this.syncExamProgress();
        
        this.showRecoveryNotification('All data synchronized successfully!');
    }
    
    activateOfflineMode() {
        // Increase backup frequency during offline
        clearInterval(powerFailureBackupInterval);
        powerFailureBackupInterval = setInterval(backupExamProgress, 10000); // Every 10 seconds
        
        // Show persistent offline indicator
        this.showPersistentOfflineWarning();
        
        // Backup current state immediately
        backupExamProgress();
    }
    
    async processOfflineBacklog() {
        if (this.offlineSubmissions.length === 0) return;
        
        console.log(`üîÑ Processing ${this.offlineSubmissions.length} offline submissions`);
        
        for (let i = 0; i < this.offlineSubmissions.length; i++) {
            const submission = this.offlineSubmissions[i];
            try {
                const success = await sendToGoogleFormWithGuarantee(
                    submission.subjData, 
                    submission.studentData
                );
                
                if (success) {
                    this.offlineSubmissions.splice(i, 1);
                    i--; // Adjust index after removal
                    this.updateOfflineStorage();
                    console.log(`‚úÖ Offline submission ${i+1} processed successfully`);
                }
            } catch (error) {
                console.error('Failed to submit offline submission:', error);
            }
            
            // Delay between submissions to avoid rate limiting
            await new Promise(resolve => setTimeout(resolve, 2000));
        }
        
        if (this.offlineSubmissions.length === 0) {
            this.showRecoveryNotification('All offline submissions processed!');
        }
    }
    
    updateOfflineStorage() {
        localStorage.setItem('offline_submissions', JSON.stringify(this.offlineSubmissions));
    }
    
    addOfflineSubmission(submission) {
        this.offlineSubmissions.push(submission);
        this.updateOfflineStorage();
        this.showOfflineBackupNotification();
    }
    
    showNetworkWarning() {
        const warningDiv = document.createElement('div');
        warningDiv.id = 'networkWarning';
        warningDiv.innerHTML = `
            <div style="position:fixed; top:0; left:0; width:100%; background:#ff9900; 
                       color:white; text-align:center; padding:10px; z-index:10000;
                       font-weight:bold; box-shadow:0 2px 10px rgba(0,0,0,0.3);">
                ‚ö†Ô∏è NETWORK CONNECTION LOST - Working offline. Your progress is being saved locally.
            </div>
        `;
        document.body.appendChild(warningDiv);
    }
    
    hideNetworkWarning() {
        const warningDiv = document.getElementById('networkWarning');
        if (warningDiv) {
            warningDiv.remove();
        }
    }
    
    showPersistentOfflineWarning() {
        this.updateNetworkStatusDisplay();
    }
    
    showOfflineBackupNotification() {
        const notification = document.createElement('div');
        notification.className = 'offline-backup-notification';
        notification.innerHTML = `
            <div>üì¶ Answer saved offline</div>
            <small>Will auto-submit when connection returns</small>
        `;
        document.body.appendChild(notification);
        
        setTimeout(() => {
            if (notification.parentNode) {
                notification.parentNode.removeChild(notification);
            }
        }, 3000);
    }
    
    showRecoveryNotification(message) {
        const notification = document.createElement('div');
        notification.className = 'recovery-notification';
        notification.textContent = message;
        document.body.appendChild(notification);
        
        setTimeout(() => {
            if (notification.parentNode) {
                notification.parentNode.removeChild(notification);
            }
        }, 5000);
    }
    
    updateNetworkStatusDisplay() {
        const statusElement = document.getElementById('enhancedNetworkStatus');
        const iconElement = document.getElementById('networkStatusIcon');
        const textElement = document.getElementById('networkStatusText');
        const qualityElement = document.getElementById('networkQuality');
        
        if (!statusElement) {
            this.createNetworkStatusElement();
            return;
        }
        
        if (this.isOnline) {
            statusElement.style.background = '#4CAF50';
            statusElement.style.color = 'white';
            iconElement.textContent = 'üåê';
            textElement.textContent = 'Online';
            
            switch(this.networkQuality) {
                case 'good':
                    qualityElement.textContent = 'Connection excellent';
                    break;
                case 'fair':
                    qualityElement.textContent = 'Connection fair';
                    statusElement.style.background = '#ff9800';
                    break;
                case 'poor':
                    qualityElement.textContent = 'Connection poor';
                    statusElement.style.background = '#f44336';
                    break;
            }
            
            // Brief show then hide when online with good connection
            if (this.networkQuality === 'good') {
                setTimeout(() => {
                    if (this.isOnline && this.networkQuality === 'good') {
                        statusElement.style.display = 'none';
                    }
                }, 3000);
            } else {
                statusElement.style.display = 'block';
            }
        } else {
            statusElement.style.background = '#ff6b6b';
            statusElement.style.color = 'white';
            iconElement.textContent = 'üî¥';
            textElement.textContent = 'Offline';
            qualityElement.textContent = `${this.offlineSubmissions.length} pending submissions`;
            statusElement.style.display = 'block';
        }
    }
    
    createNetworkStatusElement() {
        const networkStatus = document.createElement('div');
        networkStatus.id = 'enhancedNetworkStatus';
        networkStatus.innerHTML = `
            <div style="display: flex; align-items: center; gap: 8px;">
                <span id="networkStatusIcon">üåê</span>
                <div>
                    <div id="networkStatusText">Online</div>
                    <div id="networkQuality" class="network-quality-indicator">Connection excellent</div>
                </div>
            </div>
        `;
        document.body.appendChild(networkStatus);
        this.updateNetworkStatusDisplay();
    }
    
    syncExamProgress() {
        if (progress && examInProgress) {
            console.log('üîÑ Syncing exam progress...');
            backupExamProgress();
        }
    }
}

class DataPersistenceManager {
    constructor() {
        this.storageLocations = ['localStorage', 'sessionStorage', 'indexedDB'];
        this.backupInterval = null;
        this.initIndexedDB();
    }
    
    initIndexedDB() {
        if (!('indexedDB' in window)) return;
        
        const request = indexedDB.open('ExamBackupDB', 1);
        request.onupgradeneeded = (event) => {
            const db = event.target.result;
            if (!db.objectStoreNames.contains('backups')) {
                db.createObjectStore('backups');
            }
        };
    }
    
    // Triple redundancy storage
    async saveExamProgress(progress, examData) {
        const backupData = {
            progress: progress,
            examData: examData,
            timestamp: Date.now(),
            checksum: this.generateChecksum(progress),
            version: '1.0'
        };
        
        // Save to multiple locations
        const savePromises = [
            this.saveToLocalStorage(backupData),
            this.saveToSessionStorage(backupData),
            this.saveToIndexedDB(backupData)
        ];
        
        const results = await Promise.allSettled(savePromises);
        const successCount = results.filter(r => r.status === 'fulfilled' && r.value).length;
        
        console.log(`‚úÖ Backed up to ${successCount}/3 locations`);
        return successCount >= 2; // Success if at least 2 locations worked
    }
    
    async saveToLocalStorage(data) {
        try {
            // Clear old backups to avoid storage limits
            this.cleanupOldBackups('localStorage');
            
            localStorage.setItem('exam_primary_backup', JSON.stringify(data));
            localStorage.setItem('exam_backup_timestamp', Date.now().toString());
            return true;
        } catch (error) {
            console.warn('localStorage backup failed:', error);
            return false;
        }
    }
    
    async saveToSessionStorage(data) {
        try {
            sessionStorage.setItem('exam_secondary_backup', JSON.stringify(data));
            return true;
        } catch (error) {
            console.warn('sessionStorage backup failed:', error);
            return false;
        }
    }
    
    async saveToIndexedDB(data) {
        return new Promise((resolve) => {
            if (!('indexedDB' in window)) {
                resolve(false);
                return;
            }
            
            const request = indexedDB.open('ExamBackupDB', 1);
            
            request.onerror = () => resolve(false);
            request.onsuccess = (event) => {
                const db = event.target.result;
                const transaction = db.transaction(['backups'], 'readwrite');
                const store = transaction.objectStore('backups');
                
                const backupRequest = store.put(data, 'current_exam');
                backupRequest.onsuccess = () => resolve(true);
                backupRequest.onerror = () => resolve(false);
            };
        });
    }
    
    async recoverExamProgress() {
        // Try all storage locations in order of reliability
        const recoveryAttempts = [
            () => this.recoverFromLocalStorage(),
            () => this.recoverFromSessionStorage(),
            () => this.recoverFromIndexedDB()
        ];
        
        for (const attempt of recoveryAttempts) {
            const result = await attempt();
            if (result && this.validateRecoveryData(result)) {
                console.log('‚úÖ Exam progress recovered successfully');
                return result;
            }
        }
        
        console.error('‚ùå Could not recover exam progress from any storage');
        return null;
    }
    
    recoverFromLocalStorage() {
        try {
            const backup = localStorage.getItem('exam_primary_backup');
            return backup ? JSON.parse(backup) : null;
        } catch (error) {
            return null;
        }
    }
    
    recoverFromSessionStorage() {
        try {
            const backup = sessionStorage.getItem('exam_secondary_backup');
            return backup ? JSON.parse(backup) : null;
        } catch (error) {
            return null;
        }
    }
    
    recoverFromIndexedDB() {
        return new Promise((resolve) => {
            if (!('indexedDB' in window)) {
                resolve(null);
                return;
            }
            
            const request = indexedDB.open('ExamBackupDB', 1);
            request.onsuccess = (event) => {
                const db = event.target.result;
                const transaction = db.transaction(['backups'], 'readonly');
                const store = transaction.objectStore('backups');
                const backupRequest = store.get('current_exam');
                
                backupRequest.onsuccess = () => resolve(backupRequest.result || null);
                backupRequest.onerror = () => resolve(null);
            };
            request.onerror = () => resolve(null);
        });
    }
    
    validateRecoveryData(data) {
        if (!data || !data.progress || !data.examData) return false;
        
        // Verify checksum
        if (data.checksum && data.checksum !== this.generateChecksum(data.progress)) {
            console.warn('‚ö†Ô∏è Recovery data checksum mismatch');
            return false;
        }
        
        // Verify timestamp (not too old)
        const backupAge = Date.now() - data.timestamp;
        if (backupAge > 3600000) { // 1 hour
            console.warn('‚ö†Ô∏è Recovery data too old');
            return false;
        }
        
        return true;
    }
    
    generateChecksum(data) {
        const str = JSON.stringify(data);
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            const char = str.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash; // Convert to 32-bit integer
        }
        return hash.toString();
    }
    
    cleanupOldBackups(storageType) {
        try {
            // Keep only the most recent backup
            const keys = Object.keys(storageType === 'localStorage' ? localStorage : sessionStorage);
            const backupKeys = keys.filter(key => key.startsWith('exam_backup_') && key !== 'exam_backup_timestamp');
            
            // Sort by timestamp and remove old ones
            backupKeys.sort((a, b) => {
                const timeA = parseInt(localStorage.getItem(a)?.timestamp || 0);
                const timeB = parseInt(localStorage.getItem(b)?.timestamp || 0);
                return timeB - timeA;
            });
            
            // Keep only the 5 most recent backups
            for (let i = 5; i < backupKeys.length; i++) {
                if (storageType === 'localStorage') {
                    localStorage.removeItem(backupKeys[i]);
                } else {
                    sessionStorage.removeItem(backupKeys[i]);
                }
            }
        } catch (error) {
            console.warn('Cleanup failed:', error);
        }
    }
}

class IntelligentSubmissionQueue {
    constructor() {
        this.queue = JSON.parse(localStorage.getItem('submission_queue') || '[]');
        this.failedSubmissions = JSON.parse(localStorage.getItem('failed_submissions') || '[]');
        this.isProcessing = false;
        this.maxRetries = 5;
        this.retryDelays = [1000, 5000, 15000, 60000, 300000]; // Exponential backoff
        
        // Start processing if online
        if (navigator.onLine) {
            setTimeout(() => this.processQueue(), 2000);
        }
    }
    
    async addSubmission(studentData, subjData) {
        const submission = {
            id: this.generateSubmissionId(),
            studentData: studentData,
            subjData: subjData,
            timestamp: Date.now(),
            attempts: 0,
            lastAttempt: null,
            status: 'pending'
        };
        
        this.queue.push(submission);
        this.saveQueueToStorage();
        
        console.log(`üìù Added submission to queue: ${submission.id}`);
        
        // Immediate attempt if online
        if (navigator.onLine && !this.isProcessing) {
            this.processQueue();
        }
        
        return submission.id;
    }
    
    async processQueue() {
        if (this.isProcessing || this.queue.length === 0) return;
        
        this.isProcessing = true;
        console.log(`üîÑ Processing ${this.queue.length} submissions in queue`);
        
        while (this.queue.length > 0) {
            const submission = this.queue[0];
            
            // Check if we should retry based on backoff timing
            if (submission.lastAttempt && this.shouldDelayRetry(submission)) {
                console.log(`‚è≥ Delaying retry for submission ${submission.id}`);
                break;
            }
            
            try {
                const success = await this.attemptSubmission(submission);
                
                if (success) {
                    // Remove successful submission
                    this.queue.shift();
                    console.log(`‚úÖ Submission ${submission.id} successful`);
                } else {
                    submission.attempts++;
                    submission.lastAttempt = Date.now();
                    
                    if (submission.attempts >= this.maxRetries) {
                        // Move to failed queue after max retries
                        this.failedSubmissions.push(this.queue.shift());
                        console.error(`‚ùå Submission ${submission.id} failed after ${this.maxRetries} attempts`);
                    } else {
                        // Keep in queue for retry
                        console.warn(`‚ö†Ô∏è Submission ${submission.id} failed, attempt ${submission.attempts}/${this.maxRetries}`);
                    }
                }
            } catch (error) {
                console.error(`üí• Submission ${submission.id} error:`, error);
                submission.attempts++;
                submission.lastAttempt = Date.now();
            }
            
            this.saveQueueToStorage();
            
            // Brief pause between submissions
            await new Promise(resolve => setTimeout(resolve, 1000));
        }
        
        this.isProcessing = false;
        
        // Update network status display
        if (window.networkManager) {
            window.networkManager.updateNetworkStatusDisplay();
        }
    }
    
    shouldDelayRetry(submission) {
        if (submission.attempts === 0) return false;
        
        const timeSinceLastAttempt = Date.now() - submission.lastAttempt;
        const delayNeeded = this.retryDelays[Math.min(submission.attempts - 1, this.retryDelays.length - 1)];
        return timeSinceLastAttempt < delayNeeded;
    }
    
    async attemptSubmission(submission) {
        const FORM_URL = GOOGLE_FORMS[assignedForm];
        const formData = this.createFormData(submission);
        
        try {
            // Use fetch with timeout
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 15000);
            
            await fetch(FORM_URL, {
                method: "POST",
                mode: "no-cors",
                headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                body: formData,
                signal: controller.signal
            });
            
            clearTimeout(timeoutId);
            return true;
        } catch (error) {
            console.warn(`Form submission failed for ${submission.id}:`, error);
            return false;
        }
    }
    
    createFormData(submission) {
        const marks = this.calculateMarks(submission.subjData);
        const formData = new URLSearchParams();
        
        formData.append(FORM_FIELDS.STUDENT_NAME, submission.studentData.name);
        formData.append(FORM_FIELDS.SECTION, submission.studentData.sec);
        formData.append(FORM_FIELDS.ROLL_NUMBER, submission.studentData.roll);
        formData.append(FORM_FIELDS.ADMISSION_NUMBER, submission.studentData.adm);
        formData.append(FORM_FIELDS.MATHS_MARKS, marks.mathsMarks.toFixed(2));
        formData.append(FORM_FIELDS.PHYSICS_MARKS, marks.physicsMarks.toFixed(2));
        formData.append(FORM_FIELDS.CHEMISTRY_MARKS, marks.chemistryMarks.toFixed(2));
        formData.append(FORM_FIELDS.TOTAL_MARKS, marks.totalMarks.toFixed(2));
        formData.append(FORM_FIELDS.TIMESTAMP, new Date(submission.timestamp).toLocaleString());
        
        return formData;
    }
    
    calculateMarks(subjData) {
        let mathsMarks = 0, physicsMarks = 0, chemistryMarks = 0, totalMarks = 0;
        
        for (let subject in subjData) {
            const subjectLower = subject.toLowerCase().trim();
            const marks = subjData[subject].marks;
            
            if (subjectLower.includes('math')) {
                mathsMarks = marks;
            } else if (subjectLower.includes('phys')) {
                physicsMarks = marks;
            } else if (subjectLower.includes('chem')) {
                chemistryMarks = marks;
            }
            totalMarks += marks;
        }
        
        return { mathsMarks, physicsMarks, chemistryMarks, totalMarks };
    }
    
    generateSubmissionId() {
        return 'sub_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }
    
    saveQueueToStorage() {
        try {
            localStorage.setItem('submission_queue', JSON.stringify(this.queue));
            localStorage.setItem('failed_submissions', JSON.stringify(this.failedSubmissions));
        } catch (error) {
            console.error('Failed to save queue to storage:', error);
        }
    }
    
    getQueueStatus() {
        return {
            pending: this.queue.length,
            failed: this.failedSubmissions.length,
            isProcessing: this.isProcessing
        };
    }
}

class EmergencyRecoverySystem {
    constructor() {
        this.recoveryMode = false;
        this.setupEmergencyListeners();
    }
    
    setupEmergencyListeners() {
        // Detect potential data loss scenarios
        window.addEventListener('beforeunload', (e) => this.handlePageUnload(e));
        window.addEventListener('pagehide', () => this.handlePageHide());
        
        // Periodic integrity checks
        setInterval(() => this.performIntegrityCheck(), 60000);
    }
    
    handlePageUnload(e) {
        if (examInProgress && !hasSubmitted) {
            // Force immediate backup
            this.emergencyBackup();
            
            // Show custom message
            e.preventDefault();
            e.returnValue = 'Your exam progress is being saved. Please wait...';
            return e.returnValue;
        }
    }
    
    handlePageHide() {
        if (examInProgress && !hasSubmitted) {
            this.emergencyBackup();
        }
    }
    
    async emergencyBackup() {
        if (!progress) return;
        
        console.log('üö® Performing emergency backup');
        
        // Minimal backup - only essential data
        const emergencyData = {
            answers: progress.answers,
            currentQuestion: progress.currentQ,
            timeRemaining: progress.timeLeftSec,
            student: progress.student,
            timestamp: Date.now(),
            type: 'emergency'
        };
        
        // Save to multiple locations quickly
        try {
            localStorage.setItem('emergency_exam_backup', JSON.stringify(emergencyData));
            sessionStorage.setItem('emergency_exam_backup', JSON.stringify(emergencyData));
            
            // Also try to save to cookie as last resort
            document.cookie = `emergency_backup=${encodeURIComponent(JSON.stringify(emergencyData))}; max-age=86400; path=/`;
            
            console.log('‚úÖ Emergency backup completed');
        } catch (error) {
            console.error('Emergency backup failed:', error);
        }
    }
    
    async performIntegrityCheck() {
        if (!progress || hasSubmitted) return;
        
        // Verify backup integrity
        const backups = [
            localStorage.getItem('exam_primary_backup'),
            sessionStorage.getItem('exam_secondary_backup'),
            localStorage.getItem('emergency_exam_backup')
        ].filter(Boolean);
        
        if (backups.length === 0) {
            console.error('üö® No valid backups found!');
            this.triggerEmergencyBackup();
            return;
        }
        
        // Verify checksums
        for (const backupStr of backups) {
            try {
                const backup = JSON.parse(backupStr);
                if (backup.checksum) {
                    const currentChecksum = window.dataPersistenceManager.generateChecksum(progress);
                    if (backup.checksum !== currentChecksum) {
                        console.warn('‚ö†Ô∏è Backup checksum mismatch - data may be corrupted');
                        this.triggerEmergencyBackup();
                    }
                }
            } catch (error) {
                console.error('Backup integrity check failed:', error);
            }
        }
    }
    
    triggerEmergencyBackup() {
        console.log('üö® Triggering emergency backup due to integrity issues');
        this.emergencyBackup();
    }
    
    async recoverFromEmergency() {
        console.log('üîß Attempting emergency recovery');
        
        // Try all possible recovery sources
        const recoverySources = [
            () => this.recoverFromCookie(),
            () => this.recoverFromSessionStorage(),
            () => this.recoverFromLocalStorage()
        ];
        
        for (const source of recoverySources) {
            const recovered = await source();
            if (recovered) {
                console.log('‚úÖ Emergency recovery successful');
                this.showRecoverySuccess();
                return recovered;
            }
        }
        
        console.error('‚ùå Emergency recovery failed');
        this.showRecoveryFailure();
        return null;
    }
    
    recoverFromCookie() {
        try {
            const cookie = document.cookie.split('; ').find(row => row.startsWith('emergency_backup='));
            if (cookie) {
                const value = cookie.split('=')[1];
                return JSON.parse(decodeURIComponent(value));
            }
        } catch (error) {
            console.error('Cookie recovery failed:', error);
        }
        return null;
    }
    
    recoverFromSessionStorage() {
        try {
            const backup = sessionStorage.getItem('emergency_exam_backup');
            return backup ? JSON.parse(backup) : null;
        } catch (error) {
            return null;
        }
    }
    
    recoverFromLocalStorage() {
        try {
            const backup = localStorage.getItem('emergency_exam_backup');
            return backup ? JSON.parse(backup) : null;
        } catch (error) {
            return null;
        }
    }
    
    showRecoverySuccess() {
        const notification = document.createElement('div');
        notification.className = 'recovery-notification';
        notification.style.background = '#4CAF50';
        notification.textContent = '‚úÖ Exam progress recovered successfully!';
        document.body.appendChild(notification);
        
        setTimeout(() => {
            if (notification.parentNode) {
                notification.parentNode.removeChild(notification);
            }
        }, 5000);
    }
    
    showRecoveryFailure() {
        const notification = document.createElement('div');
        notification.className = 'recovery-notification';
        notification.style.background = '#f44336';
        notification.textContent = '‚ùå Could not recover exam progress';
        document.body.appendChild(notification);
        
        setTimeout(() => {
            if (notification.parentNode) {
                notification.parentNode.removeChild(notification);
            }
        }, 5000);
    }
}

// ===== ENHANCED SECURITY: 24-HOUR COOLDOWN =====
function check24HourCooldown(studentData) {
    const studentId = generateStudentId(studentData);
    const lastSubmission = localStorage.getItem(`last_submission_${studentId}`);
    
    if (lastSubmission) {
        const lastSubmissionTime = parseInt(lastSubmission);
        const currentTime = Date.now();
        const hoursSinceLastSubmission = (currentTime - lastSubmissionTime) / (1000 * 60 * 60);
        
        if (hoursSinceLastSubmission < COOLDOWN_HOURS) {
            return false; // Cooldown active
        }
    }
    
    return true; // No cooldown or cooldown expired
}

function showAccessDeniedOverlay() {
    document.getElementById('accessDeniedOverlay').style.display = 'flex';
}

function hideAccessDeniedOverlay() {
    document.getElementById('accessDeniedOverlay').style.display = 'none';
}

// ===== TAB SWITCH DETECTION =====
function setupTabSwitchDetection() {
    document.addEventListener('visibilitychange', function() {
        if (document.hidden && examInProgress && !hasSubmitted) {
            handleTabSwitch();
        }
    });
    
    // Also detect window blur (when user switches to another application)
    window.addEventListener('blur', function() {
        if (examInProgress && !hasSubmitted) {
            handleTabSwitch();
        }
    });
}

function handleTabSwitch() {
    if (tabSwitchDetected) return; // Prevent multiple triggers
    
    tabSwitchDetected = true;
    console.log('üö´ Tab switch detected - auto-submitting exam');
    
    // Show the tab switch warning
    const warningDiv = document.getElementById('tabSwitchWarning');
    warningDiv.style.display = 'flex';
    
    let countdown = 5;
    const countdownEl = document.getElementById('tabSwitchCountdown');
    countdownEl.textContent = `Submitting in ${countdown} seconds...`;
    
    tabSwitchTimeout = setInterval(() => {
        countdown--;
        countdownEl.textContent = `Submitting in ${countdown} seconds...`;
        
        if (countdown <= 0) {
            clearInterval(tabSwitchTimeout);
            warningDiv.style.display = 'none';
            calculateAndShowResults();
        }
    }, 1000);
}

// ===== ENHANCED SCREENSHOT PROTECTION =====
function setupScreenshotProtection() {
    const protection = document.getElementById('screenshotProtection');
    const block = document.getElementById('screenshotBlock');
    
    // Create multiple protection layers
    protection.innerHTML = '<div class="screenshot-dots"></div>';
    
    // Additional protection: detect and block screenshot tools
    const style = document.createElement('style');
    style.textContent = `
        /* Block common screenshot tools */
        body * {
            -webkit-user-select: none !important;
            -moz-user-select: none !important;
            -ms-user-select: none !important;
            user-select: none !important;
        }
        
        /* Disable text selection */
        ::selection {
            background: transparent !important;
        }
        ::-moz-selection {
            background: transparent !important;
        }
        
        /* Anti-screenshot patterns */
        @media print {
            body * {
                visibility: hidden !important;
            }
        }
        
        /* Disable right-click context menu */
        body {
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
    `;
    document.head.appendChild(style);
    
    // Detect screenshot attempts
    document.addEventListener('keydown', function(e) {
        if ((e.ctrlKey && e.key === 'PrintScreen') || e.key === 'PrintScreen' || 
            (e.ctrlKey && e.shiftKey && e.key === 'S') || 
            (e.metaKey && e.shiftKey && e.key === '4')) {
            e.preventDefault();
            e.stopPropagation();
            
            // Flash protection
            protection.style.background = 'rgba(255,0,0,0.3)';
            setTimeout(() => {
                protection.style.background = 'transparent';
            }, 500);
            
            return false;
        }
    });
    
    // Additional protection for right-click and drag
    document.addEventListener('dragstart', function(e) {
        e.preventDefault();
        return false;
    });
    
    document.addEventListener('selectstart', function(e) {
        e.preventDefault();
        return false;
    });
    
    // Disable right-click context menu
    document.addEventListener('contextmenu', function(e) {
        e.preventDefault();
        return false;
    });
}

// ===== POWER FAILURE SECURITY =====
let powerFailureBackupInterval = null;

function setupPowerFailureProtection() {
    // Backup progress every 30 seconds
    powerFailureBackupInterval = setInterval(() => {
        if (progress && examInProgress) {
            backupExamProgress();
        }
    }, 30000);
}

function backupExamProgress() {
    if (!progress || hasSubmitted) return;
    
    window.dataPersistenceManager.saveExamProgress(progress, examData)
        .then(success => {
            if (!success) {
                console.error('‚ùå Critical backup failure');
                window.emergencySystem.emergencyBackup();
            }
        })
        .catch(error => {
            console.error('Backup failed:', error);
            window.emergencySystem.emergencyBackup();
        });
}

function restoreExamProgress() {
    return window.dataPersistenceManager.recoverExamProgress();
}

// ===== ENHANCED ANTI-CHEATING SECURITY =====
let securityMonitorInterval = null;

function setupEnhancedSecurity() {
    // Monitor clipboard access attempts
    document.addEventListener('copy', preventClipboardAccess);
    document.addEventListener('cut', preventClipboardAccess);
    document.addEventListener('paste', preventClipboardAccess);
    
    // Monitor developer tools
    monitorDeveloperTools();
    
    // Periodic security checks
    securityMonitorInterval = setInterval(performSecurityChecks, 5000);
}

function preventClipboardAccess(e) {
    if (progress && examInProgress) {
        e.preventDefault();
        return false;
    }
}

function monitorDeveloperTools() {
    let devToolsOpen = false;
    
    const devToolsChecker = setInterval(() => {
        const widthThreshold = window.outerWidth - window.innerWidth > 160;
        const heightThreshold = window.outerHeight - window.innerHeight > 160;
        
        if (widthThreshold || heightThreshold) {
            if (!devToolsOpen && progress && examInProgress) {
                devToolsOpen = true;
                terminateExamForViolation("Developer tools detected - exam terminated");
            }
        } else {
            devToolsOpen = false;
        }
    }, 1000);
}

function performSecurityChecks() {
    if (!progress || !examInProgress) return;
    
    // Check for multiple tabs/windows
    if (window.opener || window.top !== window.self) {
        terminateExamForViolation("Multiple windows/tabs detected");
    }
    
    // Check for iframe embedding
    if (window.location !== window.parent.location) {
        terminateExamForViolation("Page embedding detected");
    }
}

function terminateExamForViolation(reason) {
    if (hasSubmitted) return;
    
    console.log(`üö´ Exam terminated: ${reason}`);
    
    // Calculate marks up to termination point
    const subjData = calculateSubjectMarks();
    
    // Mark as terminated
    subjData.terminated = true;
    subjData.terminationReason = reason;
    
    // Submit terminated exam
    sendToGoogleFormWithGuarantee(subjData, progress.student);
    
    // Show termination message
    document.getElementById('examArea').style.display = 'none';
    document.getElementById('studentEntry').style.display = 'none';
    
    const terminationDiv = document.createElement('div');
    terminationDiv.innerHTML = `
        <div style="position:fixed; top:0; left:0; width:100%; height:100%; 
                   background:linear-gradient(145deg, #ff6b6b, #dc143c); 
                   display:flex; justify-content:center; align-items:center; 
                   z-index:10000; color:white; text-align:center;">
            <div style="background:rgba(0,0,0,0.8); padding:40px; border-radius:15px; max-width:600px;">
                <h1 style="font-size:48px; margin:0 0 20px 0;">üö´ EXAM TERMINATED</h1>
                <h2 style="color:#ff6b6b; margin:0 0 20px 0;">Security Violation Detected</h2>
                <p style="font-size:18px; margin:0 0 20px 0;">Reason: ${reason}</p>
                <p style="font-size:16px; opacity:0.8;">
                    Your exam has been terminated due to violation of exam rules.<br>
                    Partial marks have been recorded up to the point of termination.
                </p>
                <button onclick="window.close()" style="
                    background:#ff6b6b; color:white; border:none; padding:12px 24px; 
                    border-radius:8px; font-size:16px; cursor:pointer; margin-top:20px;">
                    Close Window
                </button>
            </div>
        </div>
    `;
    document.body.appendChild(terminationDiv);
    
    hasSubmitted = true;
}

// ===== ENCRYPTED ANSWER KEY =====
const ENCRYPTED_ANSWER_KEY = "B,C,A,D,B,C,A,D,B,C,A,D,B,C,A,D,B,C,A,D,B,C,A,D,B,C,A,D,B,C,A,D,B,C,A,D,B,C,A,D,B,C,A,D,B,C,A,D,B,C,A,D,B,C,A,D,B,C,A,D,B,C,A,D,B,C,A,D,B,C,A,D";

function decodeAnswers(encryptedString) {
    // Simple substitution cipher - REPLACE THIS WITH YOUR OWN ENCODING!
    return encryptedString.split(',').map(char => {
        const mapping = { 'A': 'D', 'B': 'A', 'C': 'B', 'D': 'C' };
        return mapping[char] || char;
    });
}

// ===== BULLETPROOF SINGLE SUBMISSION SYSTEM =====
let submissionInProgress = new Set();

// üö® ULTRA-STRONG SINGLE SUBMISSION GUARANTEE
async function sendToGoogleFormWithGuarantee(subjData, studentData) {
    const studentId = generateStudentId(studentData);
    const submissionId = generateSubmissionId(studentData);
    
    console.log(`üöÄ Starting submission for: ${studentData.name}`);
    
    // üö® CRITICAL: Check if submission is already in progress
    if (submissionInProgress.has(studentId)) {
        console.warn(`üö® Submission already in progress for: ${studentData.name}`);
        return true; // Return true to prevent retries
    }
    
    // üö® CRITICAL: Check if already successfully submitted
    if (hasStudentAlreadySubmitted(studentData)) {
        console.warn(`üö® Student already submitted: ${studentData.name}`);
        showDuplicateInSummary();
        return true; // Return true to prevent further attempts
    }
    
    try {
        // üö® ACQUIRE SUBMISSION LOCK
        submissionInProgress.add(studentId);
        
        // Double-check duplicate prevention
        if (hasStudentAlreadySubmitted(studentData)) {
            console.warn(`üö® Duplicate detected after lock: ${studentData.name}`);
            return true;
        }
        
        console.log(`üì§ Attempting submission for: ${studentData.name}`);
        
        // Use intelligent submission queue
        const submissionId = await window.submissionQueue.addSubmission(studentData, subjData);
        console.log(`‚úÖ Submission queued with ID: ${submissionId}`);
        
        return true;
        
    } catch (error) {
        console.error(`üí• Submission error for ${studentData.name}:`, error);
        
        // Add to offline submissions as fallback
        window.networkManager.addOfflineSubmission({
            studentData: studentData,
            subjData: subjData
        });
        
        return false;
    } finally {
        // üö® RELEASE SUBMISSION LOCK (with delay to prevent rapid resubmission)
        setTimeout(() => {
            submissionInProgress.delete(studentId);
        }, 5000); // 5 second cooldown
    }
}

// üö® ENHANCED: Check if student already submitted
function hasStudentAlreadySubmitted(studentData) {
    const studentId = generateStudentId(studentData);
    
    // Check multiple storage locations
    const checks = [
        localStorage.getItem(`submitted_${studentId}`),
        sessionStorage.getItem(`submitted_${studentId}`),
        localStorage.getItem(`final_submission_${studentId}`)
    ];
    
    return checks.some(check => check !== null && check !== 'false');
}

// üö® ENHANCED: Permanent submission marker
function markAsSubmittedPermanently(studentData, submissionId) {
    const studentId = generateStudentId(studentData);
    const timestamp = Date.now();
    
    try {
        // üö® MULTIPLE LAYERS OF DUPLICATE PREVENTION
        
        // Layer 1: Primary marker
        localStorage.setItem(`submitted_${studentId}`, timestamp.toString());
        
        // Layer 2: Final submission marker
        localStorage.setItem(`final_submission_${studentId}`, timestamp.toString());
        
        // Layer 3: Session storage
        sessionStorage.setItem(`submitted_${studentId}`, timestamp.toString());
        
        // Layer 4: 24-hour cooldown marker
        localStorage.setItem(`last_submission_${studentId}`, timestamp.toString());
        
        // Layer 5: Submission history
        const submissionRecord = {
            studentId: studentId,
            submissionId: submissionId,
            timestamp: timestamp,
            studentData: studentData,
            assignedForm: assignedForm,
            status: 'completed'
        };
        
        // Store in submission history
        const history = JSON.parse(localStorage.getItem('submission_history') || '[]');
        history.push(submissionRecord);
        
        // Keep only recent history (last 20 submissions)
        if (history.length > 20) {
            history.splice(0, history.length - 20);
        }
        
        localStorage.setItem('submission_history', JSON.stringify(history));
        
        console.log(`‚úÖ PERMANENTLY MARKED AS SUBMITTED: ${studentData.name}`);
        
    } catch (error) {
        console.error('Failed to mark permanent submission:', error);
    }
}

// üö® ENHANCED: Student ID generation
function generateStudentId(studentData) {
    return `${studentData.name}_${studentData.sec}_${studentData.roll}_${studentData.adm}`
        .toLowerCase()
        .replace(/\s+/g, '_')
        .replace(/[^a-z0-9_]/g, '');
}

// üö® ENHANCED: Submission ID with better uniqueness
function generateSubmissionId(studentData) {
    const timestamp = Date.now();
    const random = Math.random().toString(36).substr(2, 9);
    return `sub_${generateStudentId(studentData)}_${timestamp}_${random}`;
}

// üö® NEW: Cleanup after submission
function cleanupAfterSubmission() {
    try {
        localStorage.removeItem('exam_backup_data');
        localStorage.removeItem('exam_primary_backup');
        sessionStorage.removeItem('exam_secondary_backup');
        localStorage.removeItem('submission_queue');
        localStorage.removeItem('offline_submissions');
        
        console.log('‚úÖ Cleaned up after submission');
    } catch (error) {
        console.error('Cleanup error:', error);
    }
}

// üö® NEW: Show submission error message
function showSubmissionError() {
    const errorDiv = document.createElement('div');
    errorDiv.innerHTML = `
        <div style="background: #f8d7da; border: 2px solid #f5c6cb; border-radius: 8px; 
                   padding: 15px; margin: 20px 0; text-align: center; font-weight: bold;">
            ‚ö†Ô∏è Submission Error: Your results may not have been recorded. 
            Please contact the administrator.
        </div>
    `;
    
    const summaryArea = document.getElementById('summaryArea');
    if (summaryArea) {
        summaryArea.prepend(errorDiv);
    }
}

// üö® ENHANCED: Show duplicate warning in summary
function showDuplicateInSummary() {
    const duplicateWarning = document.createElement('div');
    duplicateWarning.innerHTML = `
        <div style="background: #fff3cd; border: 2px solid #ffc107; border-radius: 8px; 
                   padding: 15px; margin: 20px 0; text-align: center; font-weight: bold;">
            ‚úÖ Your exam has already been submitted and recorded. 
            This is a duplicate submission attempt.
        </div>
    `;
    
    const summaryArea = document.getElementById('summaryArea');
    if (summaryArea) {
        summaryArea.prepend(duplicateWarning);
    }
}

function checkForDuplicateSubmission(studentData) {
    const studentId = generateStudentId(studentData);
    const submissionId = generateSubmissionId(studentData);
    
    // Check multiple storage locations
    const checks = [
        localStorage.getItem(`submitted_${studentId}`),
        localStorage.getItem(`submitted_${submissionId}`),
        sessionStorage.getItem(`submitted_${studentId}`)
    ];
    
    return checks.some(check => check !== null);
}

function showDuplicateWarning(studentData) {
    const duplicateWarning = document.getElementById('duplicateWarning');
    const forceStartBtn = document.getElementById('forceStartBtn');
    
    duplicateWarning.style.display = 'block';
    
    forceStartBtn.onclick = () => {
        duplicateWarning.style.display = 'none';
        startWithSecurity(true);
    };
}

// ===== PERFECT FORM ASSIGNMENT FUNCTIONS =====
function getAssignedForm(studentData) {
    const forms = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J'];
    const formsCount = forms.length;
    
    // Method 1: Perfect roll number based distribution
    if (studentData.roll && !isNaN(studentData.roll)) {
        const rollNumber = parseInt(studentData.roll);
        
        // Dynamic calculation based on actual total students
        const studentsPerForm = Math.ceil(TOTAL_STUDENTS / formsCount);
        
        // Perfect distribution formula
        const formIndex = Math.floor((rollNumber - 1) / studentsPerForm) % formsCount;
        return forms[formIndex];
    }
    
    // Method 2: Consistent hash-based fallback
    const hashString = `${studentData.name}|${studentData.roll}|${studentData.adm}`;
    let hash = 0;
    for (let i = 0; i < hashString.length; i++) {
        hash = ((hash << 5) - hash) + hashString.charCodeAt(i);
        hash = hash & hash; // Convert to 32-bit integer
    }
    return forms[Math.abs(hash) % formsCount];
}

// ===== ENHANCED QUESTION SHUFFLING =====
function shuffleArray(array) {
    const shuffled = [...array];
    for (let i = shuffled.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }
    return shuffled;
}

function createSubjectPermutation() {
    // Create different subject orders
    const subjectOrders = [
        ['Maths', 'Physics', 'Chemistry'],
        ['Physics', 'Chemistry', 'Maths'],
        ['Chemistry', 'Maths', 'Physics'],
        ['Maths', 'Chemistry', 'Physics'],
        ['Physics', 'Maths', 'Chemistry'],
        ['Chemistry', 'Physics', 'Maths']
    ];
    
    return subjectOrders[Math.floor(Math.random() * subjectOrders.length)];
}

function shuffleQuestionsForStudent(studentData) {
    // Use student data to create a unique seed for shuffling
    const seed = generateStudentId(studentData);
    const shuffledData = {
        files: [],
        keys: [],
        subjectNames: [],
        originalOrder: []
    };
    
    // Define question ranges for each subject
    const mathsQuestions = Array.from({length: 30}, (_, i) => i);
    const physicsQuestions = Array.from({length: 20}, (_, i) => i + 30);
    const chemistryQuestions = Array.from({length: 10}, (_, i) => i + 50);
    
    // Shuffle questions within each subject
    const shuffledMaths = shuffleArray(mathsQuestions);
    const shuffledPhysics = shuffleArray(physicsQuestions);
    const shuffledChemistry = shuffleArray(chemistryQuestions);
    
    // Get subject order permutation
    const subjectOrder = createSubjectPermutation();
    
    // Combine questions according to subject order
    let currentIndex = 0;
    subjectOrder.forEach(subject => {
        let subjectQuestions = [];
        let subjectKeys = [];
        
        switch(subject) {
            case 'Maths':
                subjectQuestions = shuffledMaths;
                break;
            case 'Physics':
                subjectQuestions = shuffledPhysics;
                break;
            case 'Chemistry':
                subjectQuestions = shuffledChemistry;
                break;
        }
        
        subjectQuestions.forEach(qIndex => {
            shuffledData.files[currentIndex] = images[qIndex];
            shuffledData.keys[currentIndex] = answerKey[qIndex];
            shuffledData.subjectNames[currentIndex] = subject;
            shuffledData.originalOrder[currentIndex] = qIndex;
            currentIndex++;
        });
    });
    
    return shuffledData;
}

// ===== TIMER FUNCTIONS =====
function startTimer() {
    if (timerInterval) clearInterval(timerInterval);
    
    timerInterval = setInterval(() => {
        if (!progress) return;
        
        progress.timeLeftSec--;
        
        // Update timer display
        const minutes = Math.floor(progress.timeLeftSec / 60);
        const seconds = Math.floor(progress.timeLeftSec % 60);
        const timerEl = document.getElementById('timerEl');
        timerEl.textContent = `üïí ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        
        // Blink when 5 minutes left
        if (progress.timeLeftSec <= 300 && progress.timeLeftSec > 60) {
            timerEl.classList.add('blink');
        }
        
        // Complete line blink when 1 minute left
        if (progress.timeLeftSec <= 60) {
            timerEl.classList.remove('blink');
            timerEl.classList.add('blink-line');
        }
        
        // Auto-submit when time's up
        if (progress.timeLeftSec <= 0) {
            clearInterval(timerInterval);
            autoSubmitExam();
        }
    }, 1000);
}

function autoSubmitExam() {
    if (hasSubmitted) return;
    
    console.log('‚è∞ Time up! Auto-submitting exam...');
    calculateAndShowResults();
}

// ===== QUESTION DISPLAY FUNCTIONS =====
function getCurrentSubject(qIndex) {
    return examData.subjectNames[qIndex] || "Unknown";
}

function showQuestion(qIndex) {
    if (!progress || qIndex < 0 || qIndex >= examData.files.length) return;
    
    progress.currentQ = qIndex;
    
    const container = document.getElementById('questionContainer');
    container.innerHTML = '';
    
    // Add question transition effect
    container.classList.add('question-transition');
    
    // Question number info with subject
    const qInfo = document.getElementById('stuQInfo');
    const currentSubject = getCurrentSubject(qIndex);
    qInfo.textContent = `${currentSubject} Question ${qIndex + 1}/${examData.files.length}`;
    
    // Create question image
    const img = new Image();
    img.src = examData.files[qIndex] + '?v=1.0'; // Cache busting for GitHub
    img.className = 'questionImg';
    img.alt = `Question ${qIndex + 1}`;
    
    // Loading states
    img.onload = function() {
        container.classList.remove('question-transition');
        container.classList.add('question-fade-in');
        setTimeout(() => {
            container.classList.remove('question-fade-in');
        }, 300);
    };
    
    img.onerror = function() {
        container.innerHTML = `
            <div class="image-error">
                <h3>‚ùå Image Load Error</h3>
                <p>Failed to load question ${qIndex + 1}. Please contact administrator.</p>
                <p>Image path: ${examData.files[qIndex]}</p>
            </div>
        `;
    };
    
    container.appendChild(img);
    
    // Create options
    const optionsContainer = document.createElement('div');
    optionsContainer.className = 'options-container';
    optionsContainer.innerHTML = `
        <button class="optBtn" data-opt="A">A</button>
        <button class="optBtn" data-opt="B">B</button>
        <button class="optBtn" data-opt="C">C</button>
        <button class="optBtn" data-opt="D">D</button>
    `;
    
    container.appendChild(optionsContainer);
    
    // Set current selected option
    const currentAnswer = progress.answers[qIndex];
    if (currentAnswer !== null) {
        const selectedBtn = optionsContainer.querySelector(`[data-opt="${currentAnswer}"]`);
        if (selectedBtn) selectedBtn.classList.add('selected');
    }
    
    // Add event listeners to options
    const optBtns = optionsContainer.querySelectorAll('.optBtn');
    optBtns.forEach(btn => {
        btn.addEventListener('click', () => selectOption(qIndex, btn.dataset.opt));
    });
    
    // Update palette
    updatePalette();
    
    // Update navigation buttons
    updateNavigationButtons();
}

function selectOption(qIndex, option) {
    if (!progress || hasSubmitted) return;
    
    // Toggle selection - if clicking the same option again, clear it
    if (progress.answers[qIndex] === option) {
        progress.answers[qIndex] = null;
    } else {
        progress.answers[qIndex] = option;
    }
    
    // Update button states
    const optBtns = document.querySelectorAll('.optBtn');
    optBtns.forEach(btn => {
        btn.classList.remove('selected');
        if (btn.dataset.opt === progress.answers[qIndex]) {
            btn.classList.add('selected');
        }
    });
    
    // Update palette - make answered questions green
    updatePalette();
    
    // Auto-save progress
    backupExamProgress();
}

// ===== PALETTE FUNCTIONS =====
function initPalette() {
    const palette = document.getElementById('paletteContainer');
    palette.innerHTML = '';
    
    // Determine grid columns based on screen size
    let columns = 20;
    if (window.innerWidth <= 600) columns = 5;
    else if (window.innerWidth <= 900) columns = 10;
    else if (window.innerWidth <= 1200) columns = 15;
    
    palette.style.gridTemplateColumns = `repeat(${columns}, 1fr)`;
    
    for (let i = 0; i < examData.files.length; i++) {
        const btn = document.createElement('button');
        btn.textContent = i + 1;
        btn.dataset.qIndex = i;
        
        btn.addEventListener('click', () => {
            if (!hasSubmitted) {
                showQuestion(i);
            }
        });
        
        palette.appendChild(btn);
    }
    
    updatePalette();
}

function updatePalette() {
    if (!progress) return;
    
    const paletteBtns = document.querySelectorAll('#paletteContainer button');
    paletteBtns.forEach(btn => {
        const qIndex = parseInt(btn.dataset.qIndex);
        
        // Remove all state classes
        btn.classList.remove('selected', 'reviewed', 'current', 
                           'answered', 'not-answered', 'marked-review');
        
        // Current question
        if (qIndex === progress.currentQ) {
            btn.classList.add('current');
        }
        
        // Answered questions - MAKE THEM GREEN
        if (progress.answers[qIndex] !== null) {
            btn.classList.add('selected'); // This makes it green
        }
        
        // Marked for review - MAKE THEM YELLOW
        if (progress.markedReview.has(qIndex)) {
            btn.classList.add('reviewed');
        }
    });
}

// ===== NAVIGATION FUNCTIONS =====
function updateNavigationButtons() {
    const prevBtn = document.getElementById('prevBtn');
    const nextBtn = document.getElementById('nextBtn');
    const markReviewBtn = document.getElementById('markReviewBtn');
    
    // Previous button
    prevBtn.disabled = progress.currentQ === 0;
    
    // Next button
    nextBtn.disabled = progress.currentQ === examData.files.length - 1;
    
    // Mark review button - YELLOW when marked
    if (progress.markedReview.has(progress.currentQ)) {
        markReviewBtn.textContent = 'Unmark Review';
        markReviewBtn.classList.add('reviewed');
    } else {
        markReviewBtn.textContent = 'Mark Review';
        markReviewBtn.classList.remove('reviewed');
    }
}

// Navigation event listeners
document.getElementById('prevBtn').addEventListener('click', () => {
    if (progress.currentQ > 0) {
        showQuestion(progress.currentQ - 1);
    }
});

document.getElementById('nextBtn').addEventListener('click', () => {
    if (progress.currentQ < examData.files.length - 1) {
        showQuestion(progress.currentQ + 1);
    }
});

document.getElementById('markReviewBtn').addEventListener('click', () => {
    if (!progress) return;
    
    const currentQ = progress.currentQ;
    if (progress.markedReview.has(currentQ)) {
        progress.markedReview.delete(currentQ);
    } else {
        progress.markedReview.add(currentQ);
    }
    
    updatePalette();
    updateNavigationButtons();
    backupExamProgress();
});

// ===== EXAM SUBMISSION FUNCTIONS =====
document.getElementById('submitBtn').addEventListener('click', () => {
    showConfirmModal(
        'Are you sure you want to submit the exam?',
        calculateAndShowResults
    );
});

function showConfirmModal(message, confirmCallback) {
    const modal = document.getElementById('confirmModal');
    const confirmText = document.getElementById('confirmText');
    const confirmYes = document.getElementById('confirmYes');
    const confirmNo = document.getElementById('confirmNo');
    
    confirmText.textContent = message;
    
    // Remove existing event listeners
    confirmYes.replaceWith(confirmYes.cloneNode(true));
    confirmNo.replaceWith(confirmNo.cloneNode(true));
    
    // Get new references
    const newConfirmYes = document.getElementById('confirmYes');
    const newConfirmNo = document.getElementById('confirmNo');
    
    newConfirmYes.onclick = () => {
        modal.style.display = 'none';
        confirmCallback();
    };
    
    newConfirmNo.onclick = () => {
        modal.style.display = 'none';
    };
    
    modal.style.display = 'flex';
}

// üö® ENHANCED: Calculate and show results with single submission
function calculateAndShowResults() {
    if (hasSubmitted) {
        console.warn('üö® Attempted to submit already submitted exam');
        return;
    }
    
    hasSubmitted = true;
    examInProgress = false;
    
    console.log('üìä Calculating results and submitting...');
    
    // Clear timers and intervals
    clearInterval(timerInterval);
    clearInterval(powerFailureBackupInterval);
    clearInterval(securityMonitorInterval);
    if (tabSwitchTimeout) clearInterval(tabSwitchTimeout);
    
    // Calculate subject-wise marks
    const subjData = calculateSubjectMarks();
    currentSubjData = subjData; // Store for detailed solutions
    
    // üö® SINGLE SUBMISSION CALL
    const studentData = progress.student;
    const submissionPromise = sendToGoogleFormWithGuarantee(subjData, studentData);
    
    // Show summary immediately (don't wait for submission)
    showSummary(subjData);
    
    // Monitor submission status
    submissionPromise.then(success => {
        if (success) {
            console.log('üéâ Exam submitted successfully!');
            // Clear backup data after successful submission
            cleanupAfterSubmission();
        } else {
            console.error('üí• Exam submission failed!');
            showSubmissionError();
        }
    });
}

function calculateSubjectMarks() {
    const subjData = {};
    const totalQuestions = examData.files.length;
    
    for (let i = 0; i < totalQuestions; i++) {
        const subjectName = examData.subjectNames[i];
        
        if (!subjData[subjectName]) {
            subjData[subjectName] = {
                correct: 0,
                wrong: 0,
                blank: 0,
                total: 0,
                marks: 0
            };
        }
        
        const answer = progress.answers[i];
        const correctAnswer = examData.keys[i];
        
        if (answer === null) {
            subjData[subjectName].blank++;
        } else if (answer === correctAnswer) {
            subjData[subjectName].correct++;
            subjData[subjectName].marks += MARK_PER_CORRECT;
        } else {
            subjData[subjectName].wrong++;
            subjData[subjectName].marks += MARK_PER_WRONG;
        }
        
        subjData[subjectName].total++;
    }
    
    return subjData;
}

// ===== SUMMARY AND REVIEW FUNCTIONS =====
function showSummary(subjData) {
    document.getElementById('examArea').style.display = 'none';
    document.getElementById('summaryArea').style.display = 'block';
    
    // Update student info in summary
    const student = progress.student;
    document.getElementById('summaryStudentName').textContent = student.name;
    document.getElementById('summarySection').textContent = student.sec;
    document.getElementById('summaryRoll').textContent = student.roll;
    document.getElementById('summaryAdm').textContent = student.adm;
    document.getElementById('summaryForm').textContent = assignedForm;
    
    // Create summary table
    const tableContainer = document.getElementById('summaryTableContainer');
    tableContainer.innerHTML = createSummaryTable(subjData);
    
    // Start waiting timer if exam time not completed
    const timeUsed = EXAM_DURATION_MS - (progress.timeLeftSec * 1000);
    const timeRemaining = EXAM_DURATION_MS - timeUsed;
    
    if (timeRemaining > 0) {
        startWaitingTimer(timeRemaining);
    } else {
        showAutoTransition();
    }
}

function createSummaryTable(subjData) {
    let tableHTML = `
        <table class="results-table">
            <thead>
                <tr>
                    <th>Subject</th>
                    <th>Correct</th>
                    <th>Wrong</th>
                    <th>Blank</th>
                    <th>Total</th>
                    <th>Marks</th>
                </tr>
            </thead>
            <tbody>
    `;
    
    let totalCorrect = 0, totalWrong = 0, totalBlank = 0, totalMarks = 0;
    
    for (const [subject, data] of Object.entries(subjData)) {
        tableHTML += `
            <tr>
                <td>${subject}</td>
                <td>${data.correct}</td>
                <td>${data.wrong}</td>
                <td>${data.blank}</td>
                <td>${data.total}</td>
                <td>${data.marks.toFixed(2)}</td>
            </tr>
        `;
        
        totalCorrect += data.correct;
        totalWrong += data.wrong;
        totalBlank += data.blank;
        totalMarks += data.marks;
    }
    
    tableHTML += `
            <tr class="total-row">
                <td><strong>Total</strong></td>
                <td><strong>${totalCorrect}</strong></td>
                <td><strong>${totalWrong}</strong></td>
                <td><strong>${totalBlank}</strong></td>
                <td><strong>${totalCorrect + totalWrong + totalBlank}</strong></td>
                <td><strong>${totalMarks.toFixed(2)}</strong></td>
            </tr>
        </tbody>
        </table>
    `;
    
    return tableHTML;
}

function startWaitingTimer(timeRemaining) {
    let remainingMs = timeRemaining;
    
    waitingTimerInterval = setInterval(() => {
        remainingMs -= 1000;
        
        const minutes = Math.floor(remainingMs / 60000);
        const seconds = Math.floor((remainingMs % 60000) / 1000);
        
        document.getElementById('waitingTimer').textContent = 
            `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        
        if (remainingMs <= 0) {
            clearInterval(waitingTimerInterval);
            showAutoTransition();
        }
    }, 1000);
}

function showAutoTransition() {
    document.getElementById('waitingMessage').style.display = 'none';
    document.getElementById('autoTransitionMessage').style.display = 'block';
    
    let countdown = 5;
    document.getElementById('countdown').textContent = countdown;
    
    autoTransitionTimer = setInterval(() => {
        countdown--;
        document.getElementById('countdown').textContent = countdown;
        
        if (countdown <= 0) {
            clearInterval(autoTransitionTimer);
            showDetailedSolutions();
        }
    }, 1000);
}

function showDetailedSolutions() {
    document.getElementById('summaryArea').style.display = 'none';
    document.getElementById('reviewArea').style.display = 'block';
    
    // Update student info in review
    const student = progress.student;
    document.getElementById('reviewStudentName').textContent = student.name;
    document.getElementById('reviewSection').textContent = student.sec;
    document.getElementById('reviewRoll').textContent = student.roll;
    document.getElementById('reviewAdm').textContent = student.adm;
    document.getElementById('reviewForm').textContent = assignedForm;
    
    // Create detailed results table
    const detailedContainer = document.getElementById('detailedResultsContainer');
    detailedContainer.innerHTML = createDetailedResultsTable(currentSubjData);
    
    // Create question-by-question review
    createQuestionReview();
}

function createDetailedResultsTable(subjData) {
    let tableHTML = `
        <table class="detailed-results-table">
            <thead>
                <tr>
                    <th>Subject</th>
                    <th>Correct</th>
                    <th>Wrong</th>
                    <th>Blank</th>
                    <th>Total Questions</th>
                    <th>Marks Obtained</th>
                    <th>Percentage</th>
                </tr>
            </thead>
            <tbody>
    `;
    
    let totalCorrect = 0, totalWrong = 0, totalBlank = 0, totalMarks = 0, totalQuestions = 0;
    
    for (const [subject, data] of Object.entries(subjData)) {
        const percentage = ((data.marks / (data.total * MARK_PER_CORRECT)) * 100).toFixed(2);
        const rowClass = percentage >= 40 ? 'highlight' : '';
        
        tableHTML += `
            <tr class="${rowClass}">
                <td><strong>${subject}</strong></td>
                <td>${data.correct}</td>
                <td>${data.wrong}</td>
                <td>${data.blank}</td>
                <td>${data.total}</td>
                <td>${data.marks.toFixed(2)}</td>
                <td>${percentage}%</td>
            </tr>
        `;
        
        totalCorrect += data.correct;
        totalWrong += data.wrong;
        totalBlank += data.blank;
        totalMarks += data.marks;
        totalQuestions += data.total;
    }
    
    const overallPercentage = ((totalMarks / (totalQuestions * MARK_PER_CORRECT)) * 100).toFixed(2);
    
    tableHTML += `
            <tr class="total-row">
                <td><strong>GRAND TOTAL</strong></td>
                <td><strong>${totalCorrect}</strong></td>
                <td><strong>${totalWrong}</strong></td>
                <td><strong>${totalBlank}</strong></td>
                <td><strong>${totalQuestions}</strong></td>
                <td><strong>${totalMarks.toFixed(2)}</strong></td>
                <td><strong>${overallPercentage}%</strong></td>
            </tr>
        </tbody>
        </table>
    `;
    
    return tableHTML;
}

function createQuestionReview() {
    const container = document.getElementById('reviewQuestionsContainer');
    container.innerHTML = '<h3 style="text-align:center; color:#4B0082;">Question-wise Analysis</h3>';
    
    for (let i = 0; i < examData.files.length; i++) {
        const questionDiv = document.createElement('div');
        questionDiv.className = 'question-review-item';
        questionDiv.style.cssText = `
            border: 2px solid #E6E6FA;
            border-radius: 10px;
            padding: 20px;
            margin: 15px 0;
            background: white;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        `;
        
        const studentAnswer = progress.answers[i];
        const correctAnswer = examData.keys[i];
        const isCorrect = studentAnswer === correctAnswer;
        const isAttempted = studentAnswer !== null;
        
        let statusClass = '', statusText = '', statusEmoji = '';
        
        if (!isAttempted) {
            statusClass = 'not-attempted';
            statusText = 'Not Attempted';
            statusEmoji = '‚ö™';
        } else if (isCorrect) {
            statusClass = 'correct';
            statusText = 'Correct';
            statusEmoji = '‚úÖ';
        } else {
            statusClass = 'wrong';
            statusText = 'Wrong';
            statusEmoji = '‚ùå';
        }
        
        questionDiv.innerHTML = `
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <h4 style="margin: 0; color: #4B0082;">Question ${i + 1}</h4>
                <div class="answer-status ${statusClass}">
                    ${statusEmoji} ${statusText}
                </div>
            </div>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 15px;">
                <div>
                    <strong>Your Answer:</strong> 
                    <span class="${isAttempted ? (isCorrect ? 'correct-answer' : 'wrong-answer') : ''}">
                        ${isAttempted ? studentAnswer : 'Not Attempted'}
                    </span>
                </div>
                <div>
                    <strong>Correct Answer:</strong> 
                    <span class="correct-answer">${correctAnswer}</span>
                </div>
            </div>
            
            <div style="text-align: center;">
                <img src="${examData.files[i]}" 
                     alt="Question ${i + 1}" 
                     style="max-width: 100%; height: auto; border-radius: 8px;"
                     onerror="this.style.display='none'">
            </div>
        `;
        
        container.appendChild(questionDiv);
    }
}

// ===== CLOSE BUTTONS =====
document.getElementById('closeSummaryBtn').addEventListener('click', () => {
    if (confirm('Are you sure you want to close? Detailed solutions will not be available if you close now.')) {
        window.close();
    }
});

document.getElementById('closeReviewBtn').addEventListener('click', () => {
    if (confirm('Are you sure you want to close the exam window?')) {
        window.close();
    }
});

// ===== ADMIN FUNCTIONS =====
document.getElementById('callAdminBtn').addEventListener('click', () => {
    document.getElementById('adminPassModal').style.display = 'flex';
});

document.getElementById('adminPassSubmit').addEventListener('click', () => {
    const password = document.getElementById('adminPassInput').value;
    // Add your admin password check here
    if (password === 'admin123') { // Change this to your actual password
        document.getElementById('adminPassModal').style.display = 'none';
        document.getElementById('fullRedOverlay').style.display = 'none';
        document.getElementById('accessDeniedBox').style.display = 'none';
    } else {
        alert('Incorrect password!');
    }
});

// ===== ERROR HANDLING =====
function showError(message) {
    const errorDiv = document.getElementById('errorMessages');
    errorDiv.innerHTML = `<div class="error-message">‚ùå ${message}</div>`;
}

function clearErrors() {
    document.getElementById('errorMessages').innerHTML = '';
}

// ===== ENHANCED INPUT VALIDATION =====
function validateNameInput(input) {
    const value = input.value.toUpperCase();
    input.value = value;
    
    // Allow only letters, spaces, and digits
    const isValid = /^[A-Z0-9\s\.]*$/.test(value) && value.length >= 2;
    
    if (!isValid && value !== '') {
        input.classList.add('error');
    } else {
        input.classList.remove('error');
    }
    
    return isValid;
}

function validateSectionInput(input) {
    const value = input.value.toUpperCase();
    input.value = value;
    
    // Allow only letters and digits
    const isValid = /^[A-Z0-9]*$/.test(value) && value.length >= 1;
    
    if (!isValid && value !== '') {
        input.classList.add('error');
    } else {
        input.classList.remove('error');
    }
    
    return isValid;
}

function validateRollInput(input) {
    const value = input.value;
    
    // Allow only digits
    const isValid = /^\d*$/.test(value) && value.length >= 1;
    
    if (!isValid && value !== '') {
        input.classList.add('error');
    } else {
        input.classList.remove('error');
    }
    
    return isValid;
}

function validateAdmInput(input) {
    const value = input.value;
    
    // Allow only digits
    const isValid = /^\d*$/.test(value) && value.length >= 1;
    
    if (!isValid && value !== '') {
        input.classList.add('error');
    } else {
        input.classList.remove('error');
    }
    
    return isValid;
}

function validateStudentInputs() {
    const name = document.getElementById('stuName').value.trim();
    const section = document.getElementById('stuSection').value.trim();
    const roll = document.getElementById('stuRoll').value.trim();
    const adm = document.getElementById('stuAdm').value.trim();
    
    const nameValid = validateNameInput(document.getElementById('stuName'));
    const sectionValid = validateSectionInput(document.getElementById('stuSection'));
    const rollValid = validateRollInput(document.getElementById('stuRoll'));
    const admValid = validateAdmInput(document.getElementById('stuAdm'));
    const keyValid = keyLoaded;
    
    const allValid = nameValid && sectionValid && rollValid && admValid && keyValid && name.length >= 2 && section.length >= 1 && roll.length >= 1 && adm.length >= 1;
    
    document.getElementById('stuStartBtn').style.display = allValid ? 'block' : 'none';
    
    // Show error message if key is not loaded
    if (!keyLoaded) {
        showError("Answer key not loaded - exam disabled. Contact administrator.");
    }
    
    return allValid;
}

// ===== INITIALIZATION =====
document.addEventListener('DOMContentLoaded', function() {
    console.log('üöÄ Initializing Enhanced LFJC Examination System');
    
    // Initialize enhanced network systems
    window.networkManager = new NetworkManager();
    window.dataPersistenceManager = new DataPersistenceManager();
    window.submissionQueue = new IntelligentSubmissionQueue();
    window.emergencySystem = new EmergencyRecoverySystem();
    
    // Initialize answer key securely
    answerKey = decodeAnswers(ENCRYPTED_ANSWER_KEY);
    keyLoaded = true;
    
    // Build image paths
    for (let i = 1; i <= answerKey.length; i++) {
        images.push(`questions/${i}.png`);
    }
    
    // Setup security systems
    setupScreenshotProtection();
    setupTabSwitchDetection();
    setupEnhancedSecurity();
    setupPowerFailureProtection();
    
    // Check for existing exam progress
    if (restoreExamProgress()) {
        showResumeOption();
    }
    
    // Initialize event listeners
    initializeEventListeners();
    
    console.log('‚úÖ Enhanced LFJC Examination System Ready');
});

function initializeEventListeners() {
    // Student input validation with immediate feedback
    document.getElementById('stuName').addEventListener('input', function() {
        validateNameInput(this);
        validateStudentInputs();
    });
    
    document.getElementById('stuSection').addEventListener('input', function() {
        validateSectionInput(this);
        validateStudentInputs();
    });
    
    document.getElementById('stuRoll').addEventListener('input', function() {
        validateRollInput(this);
        validateStudentInputs();
    });
    
    document.getElementById('stuAdm').addEventListener('input', function() {
        validateAdmInput(this);
        validateStudentInputs();
    });
    
    // Start button
    document.getElementById('stuStartBtn').addEventListener('click', startWithSecurity);
    
    // Resume button
    document.getElementById('resumeExamBtn').addEventListener('click', resumeExam);
    
    // Setup admin override for access denied
    document.getElementById('adminOverrideBtn').addEventListener('click', function() {
        const password = document.getElementById('adminOverridePass').value;
        if (password === ADMIN_PASSWORD) {
            hideAccessDeniedOverlay();
            // Allow the student to proceed
            document.getElementById('stuStartBtn').style.display = 'block';
        } else {
            alert('Incorrect admin password!');
        }
    });
}

function startWithSecurity(forceStart = false) {
    if (!validateStudentInputs() && !forceStart) return;
    
    const studentData = {
        name: document.getElementById('stuName').value.trim(),
        sec: document.getElementById('stuSection').value.trim(),
        roll: document.getElementById('stuRoll').value.trim(),
        adm: document.getElementById('stuAdm').value.trim()
    };
    
    const studentId = generateStudentId(studentData);
    
    // Enhanced 24-hour cooldown check
    if (!forceStart && !check24HourCooldown(studentData)) {
        showAccessDeniedOverlay();
        return;
    }
    
    // Enhanced duplicate check
    if (!forceStart && checkForDuplicateSubmission(studentData)) {
        showDuplicateWarning(studentData);
        return;
    }
    
    // Clear any existing backup to prevent conflicts
    localStorage.removeItem('exam_backup_data');
    
    startExam(studentData);
}

function startExam(studentData) {
    examInProgress = true;
    examStartTime = Date.now();
    tabSwitchDetected = false;
    
    // Get form assignment (but don't display it)
    assignedForm = getAssignedForm(studentData);
    
    // Shuffle questions for this student
    examData = shuffleQuestionsForStudent(studentData);
    
    // Initialize progress
    progress = {
        student: studentData,
        answers: new Array(examData.files.length).fill(null),
        currentQ: 0,
        timeLeftSec: EXAM_DURATION_MS / 1000,
        markedReview: new Set()
    };
    
    // Show exam area
    document.getElementById('studentEntry').style.display = 'none';
    document.getElementById('examArea').style.display = 'block';
    document.getElementById('examWarning').style.display = 'block';
    
    // Update student info
    document.getElementById('stuInfo').textContent = 
        `${studentData.name} | ${studentData.sec} | Roll: ${studentData.roll}`;
    
    // Start timer
    startTimer();
    
    // Initialize question palette
    initPalette();
    
    // Load first question
    showQuestion(0);
    
    // Initial backup
    backupExamProgress();
    
    console.log('‚úÖ Exam started successfully');
}

function showResumeOption() {
    document.getElementById('resumeExamSection').style.display = 'block';
}

function resumeExam() {
    const recovered = restoreExamProgress();
    if (recovered) {
        examInProgress = true;
        tabSwitchDetected = false;
        
        progress = recovered.progress;
        examData = recovered.examData;
        examStartTime = recovered.timestamp;
        
        document.getElementById('studentEntry').style.display = 'none';
        document.getElementById('examArea').style.display = 'block';
        document.getElementById('examWarning').style.display = 'block';
        
        // Update student info
        const studentData = progress.student;
        document.getElementById('stuInfo').textContent = 
            `${studentData.name} | ${studentData.sec} | Roll: ${studentData.roll}`;
        
        // Restart timer
        startTimer();
        
        // Initialize question palette
        initPalette();
        
        // Show current question
        showQuestion(progress.currentQ);
        
        console.log('‚úÖ Exam resumed from backup');
        
        // Show recovery notification
        window.networkManager.showRecoveryNotification('Exam progress restored successfully!');
    }
}

// Debug: Check system status
setInterval(() => {
    if (window.submissionQueue) {
        const status = window.submissionQueue.getQueueStatus();
        console.log('Submission Queue:', status);
    }
}, 30000);

console.log('üöÄ LFJC ONLINE EXAMINATION System with Enhanced Network Coverage Initialized');
</script>
</body>
</html>
