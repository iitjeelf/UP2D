<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>LFJC Online Exam System</title>
<style>
/* ===== BASE STYLES ===== */
:root {
  --primary-color: #4B0082;
  --secondary-color: #D8BFD8;
  --light-purple: #E6E6FA;
  --white: #fff;
  --black: #000;
  --success: #32CD32;
  --warning: #ff9900;
  --danger: #ff6666;
  --shadow: 0 5px 15px rgba(0,0,0,0.1);
  --transition: all 0.3s ease;
}

* {
  box-sizing: border-box;
}

body {
  font-family: "SF Pro Display", Arial, sans-serif;
  margin: 0;
  background: var(--white);
  color: var(--black);
  line-height: 1.6;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

/* Disable right-click context menu */
body {
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

/* Enhanced Screenshot protection */
#screenshotProtection {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: transparent;
  z-index: 2147483647;
  pointer-events: none;
}

.screenshot-dots {
  position: absolute;
  width: 100%;
  height: 100%;
  background: 
    radial-gradient(circle at 10% 20%, rgba(255,255,255,0.02) 1px, transparent 1px),
    radial-gradient(circle at 30% 40%, rgba(255,255,255,0.02) 1px, transparent 1px),
    radial-gradient(circle at 50% 60%, rgba(255,255,255,0.02) 1px, transparent 1px),
    radial-gradient(circle at 70% 80%, rgba(255,255,255,0.02) 1px, transparent 1px),
    radial-gradient(circle at 90% 10%, rgba(255,255,255,0.02) 1px, transparent 1px);
  background-size: 200px 200px;
  animation: flicker 0.5s infinite;
}

@keyframes flicker {
  0%, 100% { opacity: 0.8; }
  50% { opacity: 0.9; }
}

/* Additional screenshot protection */
#screenshotBlock {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: transparent;
  z-index: 2147483646;
  pointer-events: none;
}

/* ===== ANTI-TAB SWITCHING OVERLAY ===== */
#tabSwitchWarning {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.95);
  color: white;
  display: none;
  justify-content: center;
  align-items: center;
  flex-direction: column;
  z-index: 99999;
  font-family: Arial, sans-serif;
  text-align: center;
}

#tabSwitchWarning h1 {
  font-size: 48px;
  color: #ff4444;
  margin-bottom: 20px;
  text-shadow: 0 2px 10px rgba(255, 0, 0, 0.5);
}

#tabSwitchWarning p {
  font-size: 24px;
  margin-bottom: 30px;
  max-width: 80%;
  line-height: 1.5;
}

#tabSwitchWarning .warning-icon {
  font-size: 80px;
  margin-bottom: 30px;
  animation: pulse 1.5s infinite;
}

@keyframes pulse {
  0% { transform: scale(1); }
  50% { transform: scale(1.1); }
  100% { transform: scale(1); }
}

/* ===== HEADER & FOOTER ===== */
header {
  background: linear-gradient(145deg, var(--light-purple), var(--secondary-color));
  color: var(--primary-color);
  text-align: center;
  padding: 20px;
  font-size: 36px;
  font-weight: 700;
  letter-spacing: 1.5px;
  box-shadow: var(--shadow);
  text-shadow: 0 1px 2px var(--white);
}

footer {
  background: var(--light-purple);
  color: var(--primary-color);
  padding: 10px;
  text-align: center;
  font-weight: bold;
  position: fixed;
  width: 100%;
  bottom: 0;
}

/* ===== STUDENT ENTRY SECTION ===== */
#studentEntry {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  min-height: calc(100vh - 140px);
  padding: 16px;
  text-align: center;
}

.form-group {
  display: flex;
  flex-direction: row;
  align-items: center;
  justify-content: center;
  margin-bottom: 60px;
  width: 100%;
  max-width: 500px;
}

.form-group label {
  font-size: 1.15rem;
  font-weight: 600;
  margin-right: 10px;
  color: var(--primary-color);
  width: 180px;
  text-align: right;
}

input[type="text"] {
  padding: 12px 14px;
  font-size: 1.1rem;
  border-radius: 10px;
  border: 1.5px solid var(--primary-color);
  outline: none;
  min-width: 250px;
  transition: var(--transition);
}

input[type="text"]:focus {
  border-color: var(--primary-color);
  box-shadow: 0 0 0 3px rgba(75, 0, 130, 0.2);
}

input.error {
  animation: glowRed 0.5s alternate infinite;
  border-color: var(--danger);
}

@keyframes glowRed {
  0% { box-shadow: 0 0 5px var(--danger); }
  100% { box-shadow: 0 0 15px var(--danger); }
}

/* ===== BUTTON STYLES ===== */
button {
  position: relative;
  overflow: hidden;
  cursor: pointer;
  border: none;
  border-radius: 12px;
  transition: var(--transition);
  box-shadow: 0 6px #aaa;
  background: linear-gradient(to bottom, #fafaff, #dcd6f7);
  color: var(--primary-color);
  font-weight: 600;
  padding: 12px 24px;
  font-size: 18px;
}

button:hover {
  transform: translateY(-2px);
  box-shadow: 0 8px 15px rgba(0,0,0,.28);
}

button:active {
  transform: translateY(3px) scale(.98);
}

button:focus {
  outline: 2px solid var(--primary-color);
  outline-offset: 2px;
}

.optBtn {
  font-size: 16px;
  padding: 8px 18px;
  margin: 6px;
  border: 2px solid var(--primary-color);
  background: var(--white);
  border-radius: 8px;
  box-shadow: 0 5px #aaa;
}

.optBtn.selected {
  background: var(--success);
  color: var(--white);
  border-color: #2fa92f;
}

.optBtn.correct {
  background: #32CD32;
  color: white;
  border-color: #228B22;
}

.optBtn.wrong {
  background: #FF6B6B;
  color: white;
  border-color: #DC143C;
}

.optBtn.not-attempted {
  background: #B0B0B0;
  color: white;
  border-color: #808080;
}

.navBtn {
  font-size: 16px;
  padding: 10px 20px;
  border-radius: 8px;
  color: var(--white);
  font-weight: bold;
  cursor: pointer;
  background: linear-gradient(145deg, #1E90FF, #4682B4);
  margin: 0 15px;
}

#markReviewBtn {
  background: linear-gradient(145deg, #ffb84d, var(--warning));
}

#submitBtn {
  background: linear-gradient(145deg, #c8b88a, #b49e60);
}

/* ===== TIMER STYLES ===== */
#timerEl {
  font-size: 20px;
  font-weight: bold;
  color: var(--primary-color);
  padding: 6px 12px;
  border-radius: 6px;
  background: #f0f0ff;
  display: inline-block;
  transition: var(--transition);
}

#timerEl.blink {
  animation: blinkTimer 1s infinite;
}

@keyframes blinkTimer {
  0% { background: var(--danger); color: var(--white); }
  50% { background: var(--white); color: var(--primary-color); }
  100% { background: var(--danger); color: var(--white); }
}

/* ===== PALETTE STYLES ===== */
#paletteContainer {
  display: grid;
  gap: 8px;
  margin: 20px auto;
  max-width: 100%;
  padding: 0 10px;
  justify-content: center;
}

#paletteContainer button {
  width: 40px;
  height: 40px;
  border-radius: 50%;
  font-size: 14px;
  margin: 2px;
  border: 1px solid var(--primary-color);
  background: var(--light-purple);
  color: var(--primary-color);
  display: flex;
  align-items: center;
  justify-content: center;
}

#paletteContainer button.selected {
  background: var(--success);
  color: var(--white);
  border-color: #2fa92f;
}

#paletteContainer button.reviewed {
  background: yellow;
  color: var(--black);
}

#paletteContainer button.current {
  border: 3px solid red;
}

#paletteContainer button.correct-answer {
  background: #32CD32;
  color: white;
}

#paletteContainer button.wrong-answer {
  background: #FF6B6B;
  color: white;
}

#paletteContainer button.not-attempted-answer {
  background: #B0B0B0;
  color: white;
}

/* ===== EXAM AREA STYLES ===== */
#examArea {
  padding: 16px;
  text-align: center;
  display: none;
}

#examHeader {
  display: flex;
  align-items: center;
  width: 100%;
  font-weight: bold;
  margin-bottom: 20px;
}

#stuInfo {
  flex: 0 0 auto;
  text-align: left;
  white-space: nowrap;
}

#stuQInfo {
  flex: 1;
  text-align: center;
  white-space: nowrap;
}

.sectionTitle {
  font-size: 22px;
  color: var(--primary-color);
  font-weight: bold;
  margin-bottom: 8px;
}

img.questionImg {
  max-width: 95vw;
  width: auto;
  height: auto;
  border-radius: 10px;
  -webkit-user-drag: none;
  -khtml-user-drag: none;
  -moz-user-drag: none;
  -o-user-drag: none;
  user-drag: none;
  display: block;
  margin-left: auto;
  margin-right: auto;
  transition: opacity 0.3s ease;
}

/* ===== ANIMATIONS ===== */
.glow {
  animation: glowPulse 1.6s infinite alternate;
  box-shadow: 0 8px 18px rgba(75,0,130,0.12);
}

@keyframes glowPulse {
  0% { box-shadow: 0 6px 10px rgba(75,0,130,0.06); transform: translateY(0); }
  50% { box-shadow: 0 12px 30px rgba(75,0,130,0.14); transform: translateY(-2px); }
  100% { box-shadow: 0 6px 10px rgba(75,0,130,0.06); transform: translateY(0); }
}

/* ===== SECURITY OVERLAY STYLES ===== */
#fullRedOverlay {
  position: fixed;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  display: none;
  background: red;
  z-index: 9999;
  pointer-events: auto;
}

#accessDeniedBox {
  position: fixed;
  left: 50%;
  top: 40%;
  transform: translate(-50%, -50%);
  z-index: 10000;
  color: var(--white);
  text-align: center;
  display: none;
  pointer-events: auto;
}

#accessDeniedBox h1 {
  font-size: 48px;
  font-weight: 900;
  margin: 0 0 18px 0;
  color: var(--white);
  text-shadow: 0 2px 6px rgba(0,0,0,0.4);
}

#callAdminBtn {
  padding: 12px 22px;
  border-radius: 12px;
  font-weight: 800;
}

/* ===== MODAL STYLES ===== */
.confirmModal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0,0,0,0.45);
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 10001;
}

.confirmBox {
  background: var(--white);
  padding: 20px;
  border-radius: 12px;
  min-width: 280px;
  text-align: center;
  box-shadow: 0 5px 15px rgba(0,0,0,0.3);
}

.confirmBox p {
  font-size: 18px;
  color: var(--primary-color);
  margin-bottom: 15px;
}

.confirmBox button {
  margin: 0 10px;
  padding: 8px 16px;
  font-size: 16px;
  cursor: pointer;
}

#adminPassModal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0,0,0,0.6);
  display: none;
  justify-content: center;
  align-items: center;
  z-index: 20000;
}

#adminPassBox {
  background: var(--white);
  padding: 20px;
  text-align: center;
  width: 260px;
  border-radius: 12px;
}

#adminPassBox input {
  width: 90%;
  padding: 10px;
  border: 1px solid var(--primary-color);
  border-radius: 8px;
  margin-bottom: 10px;
}

/* ===== TIMER WARNING STYLES ===== */
.blinkLine {
  animation: blinkLineAnim 1s infinite;
}

@keyframes blinkLineAnim {
  0% { background: #ffcccc; }
  50% { background: var(--white); }
  100% { background: #ffcccc; }
}

/* ===== FONT SIZE ADJUSTMENTS ===== */
#stuInfo, #stuQInfo, #timerEl {
  font-size: 20px !important;
}

/* Increase table row height vertically */
table td, table th {
  padding-top: 20px;
  padding-bottom: 20px;
}

/* ===== RESPONSIVE STYLES ===== */
@media (max-width: 600px) {
  #accessDeniedBox h1 {
    font-size: 28px;
  }
  
  #callAdminBtn {
    padding: 10px 14px;
  }
  
  .form-group {
    flex-direction: column;
    align-items: flex-start;
  }
  
  .form-group label {
    text-align: left;
    width: auto;
    margin-bottom: 5px;
  }
  
  #examHeader {
    flex-direction: column;
    gap: 10px;
  }
  
  #stuInfo, #stuQInfo {
    text-align: center;
  }
  
  .navContainer {
    flex-direction: column;
    align-items: center;
  }
  
  .navBtn {
    width: 80%;
    margin-bottom: 10px;
    margin-left: 0;
    margin-right: 0;
  }
  
  #paletteContainer {
    grid-template-columns: repeat(5, 1fr) !important;
    gap: 6px;
  }
  
  #paletteContainer button {
    width: 35px;
    height: 35px;
    font-size: 12px;
  }
}

@media (min-width: 601px) and (max-width: 900px) {
  #paletteContainer {
    grid-template-columns: repeat(10, 1fr) !important;
  }
}

@media (min-width: 901px) and (max-width: 1200px) {
  #paletteContainer {
    grid-template-columns: repeat(15, 1fr) !important;
  }
}

@media (min-width: 1201px) {
  #paletteContainer {
    grid-template-columns: repeat(20, 1fr) !important;
  }
}

/* ===== ERROR MESSAGE STYLES ===== */
.error-message {
  color: #ff3333;
  font-weight: 600;
  padding: 10px;
  margin: 10px 0;
  border-radius: 6px;
  background: rgba(255, 102, 102, 0.1);
  border: 1px solid #ff6666;
  animation: blinkRed 1s infinite;
}

@keyframes blinkRed {
  0% { opacity: 1; }
  50% { opacity: 0.6; }
  100% { opacity: 1; }
}

/* ===== RESULTS TABLE STYLES ===== */
.results-table {
  width: 100%;
  max-width: 900px;
  margin: 20px auto;
  border-collapse: collapse;
  font-size: 18px;
  text-align: center;
}

.results-table th {
  background: #E6E6FA;
  padding: 15px;
  border: 1px solid var(--primary-color);
}

.results-table td {
  padding: 15px;
  border: 1px solid var(--primary-color);
}

.results-table tr:nth-child(even) {
  background: #f9f9f9;
}

.results-table tr:hover {
  background: #f0f0ff;
}

/* ===== REVIEW MODE STYLES ===== */
.answer-status {
  margin: 10px 0;
  padding: 10px;
  border-radius: 8px;
  font-weight: bold;
}

.answer-status.correct {
  background: #d4edda;
  color: #155724;
  border: 1px solid #c3e6cb;
}

.answer-status.wrong {
  background: #f8d7da;
  color: #721c24;
  border: 1px solid #f5c6cb;
}

.answer-status.not-attempted {
  background: #e2e3e5;
  color: #383d41;
  border: 1px solid #d6d8db;
}

.correct-answer {
  color: #155724;
  font-weight: bold;
}

.wrong-answer {
  color: #721c24;
  font-weight: bold;
}

/* ===== AREA STYLES ===== */
#summaryArea, #reviewArea {
  display: none;
  padding: 20px;
}

.area-header {
  text-align: center;
  margin-bottom: 30px;
}

.area-header h2 {
  color: #4B0082;
  margin-bottom: 10px;
}

/* ===== VERTICAL GAP STYLES ===== */
.options-container {
  margin-bottom: 60px;
}

.navContainer {
  margin-top: 40px;
  display: flex;
  justify-content: center;
  gap: 20px;
  flex-wrap: wrap;
}

/* ===== SECURITY MESSAGE STYLES ===== */
.security-message {
  background: #fff3cd;
  border: 1px solid #ffeaa7;
  color: #856404;
  padding: 15px;
  border-radius: 8px;
  margin: 20px 0;
  text-align: center;
  font-weight: bold;
}

/* ===== AUTO TRANSITION STYLES ===== */
.auto-transition-message {
  background: #d4edda;
  border: 1px solid #c3e6cb;
  color: #155724;
  padding: 15px;
  border-radius: 8px;
  margin: 20px 0;
  text-align: center;
  font-weight: bold;
  animation: pulse 2s infinite;
}

@keyframes pulse {
  0% { transform: scale(1); }
  50% { transform: scale(1.02); }
  100% { transform: scale(1); }
}

.waiting-message {
  background: #d1ecf1;
  border: 1px solid #bee5eb;
  color: #0c5460;
  padding: 20px;
  border-radius: 8px;
  margin: 30px 0;
  text-align: center;
  font-weight: bold;
  font-size: 18px;
}

.waiting-timer {
  font-size: 24px;
  font-weight: bold;
  color: #4B0082;
  margin: 10px 0;
}

/* ===== LOADING STYLES ===== */
.loading-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 40px;
  text-align: center;
}

.spinner {
  border: 5px solid #f3f3f3;
  border-top: 5px solid #4B0082;
  border-radius: 50%;
  width: 50px;
  height: 50px;
  animation: spin 1s linear infinite;
  margin-bottom: 20px;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

/* ===== WARNING BANNER STYLES ===== */
.warning-banner {
  background: #ffcccc;
  color: #721c24;
  padding: 15px;
  text-align: center;
  font-weight: bold;
  border: 1px solid #f5c6cb;
  border-radius: 8px;
  margin: 20px 0;
}

/* ===== IMAGE ERROR STYLES ===== */
.image-error {
  background: #ffebee;
  border: 2px solid #ffcdd2;
  color: #c62828;
  padding: 20px;
  border-radius: 8px;
  margin: 20px 0;
  text-align: center;
  font-weight: bold;
}

.image-error h3 {
  margin: 0 0 10px 0;
  color: #c62828;
}

.loading-message {
  background: #e3f2fd;
  border: 2px solid #bbdefb;
  color: #1565c0;
  padding: 15px;
  border-radius: 8px;
  margin: 10px 0;
  text-align: center;
  font-weight: bold;
}

/* ===== SUCCESS MESSAGE STYLES ===== */
.success-message {
  background: #d4edda;
  color: #155724;
  padding: 20px;
  border-radius: 8px;
  margin: 20px 0;
  text-align: center;
  font-weight: bold;
  border: 1px solid #c3e6cb;
}

.success-message h3 {
  margin: 0 0 10px 0;
  color: #155724;
}

/* ===== SMOOTH TRANSITION STYLES ===== */
.question-transition {
  transition: all 0.3s ease-in-out;
}

.question-fade-in {
  animation: fadeIn 0.3s ease-in-out;
}

@keyframes fadeIn {
  from { opacity: 0; transform: translateY(10px); }
  to { opacity: 1; transform: translateY(0); }
}

/* ===== PRELOADING STYLES ===== */
.preload-image {
  position: absolute;
  left: -9999px;
  top: -9999px;
  opacity: 0;
}

/* ===== DETAILED RESULTS TABLE STYLES ===== */
.detailed-results-table {
  width: 100%;
  max-width: 900px;
  margin: 30px auto;
  border-collapse: collapse;
  font-size: 18px;
  text-align: center;
  box-shadow: 0 4px 8px rgba(0,0,0,0.1);
}

.detailed-results-table th {
  background: #4B0082;
  color: white;
  padding: 18px;
  border: 1px solid var(--primary-color);
  font-weight: bold;
}

.detailed-results-table td {
  padding: 18px;
  border: 1px solid var(--primary-color);
}

.detailed-results-table tr:nth-child(even) {
  background: #f8f6ff;
}

.detailed-results-table tr:hover {
  background: #f0f0ff;
  transform: scale(1.01);
  transition: transform 0.2s ease;
}

.detailed-results-table .total-row {
  background: #E6E6FA !important;
  font-weight: bold;
  font-size: 20px;
}

.detailed-results-table .highlight {
  background: #d4edda;
  font-weight: bold;
}

/* ===== FORM ASSIGNMENT STYLES ===== */
.form-assignment {
  background: #e8f4fd;
  border: 2px solid #4B0082;
  border-radius: 10px;
  padding: 15px;
  margin: 15px 0;
  text-align: center;
}

.form-assignment h3 {
  color: #4B0082;
  margin: 0 0 10px 0;
}

.assigned-form {
  font-size: 24px;
  font-weight: bold;
  color: #4B0082;
  background: white;
  padding: 10px 20px;
  border-radius: 8px;
  display: inline-block;
  margin: 10px 0;
}

/* ===== DATA PROTECTION STYLES ===== */
.data-protection-banner {
  background: #d4edda;
  border: 2px solid #28a745;
  color: #155724;
  padding: 15px;
  border-radius: 8px;
  margin: 20px 0;
  text-align: center;
  font-weight: bold;
}

.backup-status {
  background: #e2e3e5;
  border: 1px solid #d6d8db;
  color: #383d41;
  padding: 10px;
  border-radius: 6px;
  margin: 10px 0;
  font-size: 14px;
  text-align: center;
}

.submission-status {
  background: #cce7ff;
  border: 1px solid #b3d9ff;
  color: #004085;
  padding: 10px;
  border-radius: 6px;
  margin: 10px 0;
  font-size: 14px;
  text-align: center;
}

.network-status {
  background: #fff3cd;
  border: 1px solid #ffeaa7;
  color: #856404;
  padding: 10px;
  border-radius: 6px;
  margin: 10px 0;
  font-size: 14px;
  text-align: center;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  z-index: 10000;
}

.duplicate-warning {
  background: #f8d7da;
  border: 2px solid #f5c6cb;
  color: #721c24;
  padding: 15px;
  border-radius: 8px;
  margin: 20px 0;
  text-align: center;
  font-weight: bold;
}
</style>
</head>

<body>

<!-- Anti-Tab Switching Warning -->
<div id="tabSwitchWarning">
  <div class="warning-icon">‚ö†Ô∏è</div>
  <h1>TAB SWITCHING DETECTED</h1>
  <p>You have switched away from the exam window. This is a violation of exam rules.</p>
  <p><strong>Return to the exam immediately to continue.</strong></p>
  <p>Multiple violations may result in exam disqualification.</p>
</div>

<header>LFJC ONLINE EXAMINATION - 10 FORM SYSTEM</header>

<!-- Data Recovery Dashboard -->
<div id="dataRecoveryDashboard" style="display:none;">
  <div class="warning-banner">
    <h3>üõ°Ô∏è DATA RECOVERY DASHBOARD</h3>
    <p><strong>Pending Submissions:</strong> <span id="pendingCount">0</span></p>
    <p><strong>Active Backups:</strong> <span id="backupCount">0</span> students</p>
    <p><strong>Successful Submissions:</strong> <span id="successCount">0</span> students</p>
    <button onclick="exportAllBackupData()" class="navBtn">üì• Export All Backup Data</button>
    <button onclick="cleanAllDuplicateData()" class="navBtn" style="background:linear-gradient(145deg, #dc3545, #c82333);">üßπ Clean Duplicate Data</button>
    <button onclick="clearAllSubmissions()" class="navBtn" style="background:linear-gradient(145deg, #dc3545, #c82333);">üóëÔ∏è Clear All Submissions</button>
  </div>
</div>

<div id="studentEntry">
  <div class="warning-banner" id="examWarning" style="display:none;">
    <p>‚ö†Ô∏è WARNING: Exam in progress. Do not refresh or close this window!</p>
  </div>
  
  <!-- Data Protection Status -->
  <div class="data-protection-banner">
    <p>üõ°Ô∏è ALL ANSWERS ARE AUTOMATICALLY BACKED UP - NO DATA LOSS</p>
  </div>
  
  <div class="form-group"><label>NAME</label><input type="text" id="stuName" placeholder="Only letters & spaces" autocomplete="off"></div>
  <div class="form-group"><label>SECTION</label><input type="text" id="stuSection" placeholder="Letters & digits" autocomplete="off"></div>
  <div class="form-group"><label>ROLL NUMBER</label><input type="text" id="stuRoll" placeholder="Digits only" autocomplete="off"></div>
  <div class="form-group"><label>ADMISSION NUMBER</label><input type="text" id="stuAdm" placeholder="Digits only" autocomplete="off"></div>
  
  <!-- Form Assignment Display -->
  <div id="formAssignment" class="form-assignment" style="display:none;">
    <h3>üìã ASSIGNED FORM</h3>
    <div class="assigned-form" id="assignedFormDisplay">FORM A</div>
    <p>Your responses will be submitted to this form</p>
  </div>
  
  <div class="form-group"><button id="stuStartBtn" style="display:none;">Start Exam</button></div>
  <p id="studentMsg"></p>
  <div id="errorMessages"></div>
  
  <!-- Duplicate Warning -->
  <div id="duplicateWarning" class="duplicate-warning" style="display:none;">
    <h3>‚ö†Ô∏è DUPLICATE ENTRY DETECTED</h3>
    <p>This student data already exists in the system.</p>
    <button id="forceStartBtn" class="navBtn" style="background:linear-gradient(145deg, #dc3545, #c82333);">Force Start Anyway</button>
  </div>
  
  <div id="resumeExamSection" style="display:none; margin-top: 20px;">
    <div class="security-message">
      <p>You have an exam in progress. Would you like to resume?</p>
      <button id="resumeExamBtn" class="navBtn">Resume Exam</button>
    </div>
  </div>
</div>

<div id="examArea" style="display:none;">
  <div id="examHeader" style="display:flex;align-items:center;width:100%;font-weight:bold;">
    <div id="stuInfo" style="flex:0 0 auto;text-align:left; white-space:nowrap;"></div>
    <div id="stuQInfo" style="flex:1;text-align:center; white-space:nowrap;"></div>
    <div style="flex:0 0 auto;text-align:right; white-space:nowrap;">
        <span id="timerEl">üïí 00:00</span>
    </div>
  </div>

  <!-- Real-time Backup Status -->
  <div class="backup-status" id="backupStatus">
    üíæ Auto-backup active - All answers are secured
  </div>

  <!-- Network Status -->
  <div class="network-status" id="networkStatus" style="display:none;">
    üìµ You are offline - Answers are being saved locally
  </div>

  <!-- Submission Status -->
  <div class="submission-status" id="submissionStatus" style="display:none;">
    ‚úÖ Already submitted - Resubmission prevented
  </div>

  <div id="questionContainer" style="text-align:center;margin-top:10px;"></div>

  <div class="navContainer">
    <button class="navBtn" id="prevBtn">‚¨Ö Previous</button>
    <button class="navBtn" id="markReviewBtn">Review</button>
    <button class="navBtn" id="nextBtn">Next ‚û°</button>
    <button class="navBtn" id="submitBtn">Submit Exam</button>
  </div>

  <div id="paletteContainer"></div>
</div>

<!-- Summary Area -->
<div id="summaryArea">
  <div class="area-header">
    <h2>üìä Exam Summary - <span id="summaryStudentName"></span></h2>
    <div>
      <b>Section:</b> <span id="summarySection"></span> | 
      <b>Roll:</b> <span id="summaryRoll"></span> | 
      <b>Admission No:</b> <span id="summaryAdm"></span> |
      <b>Form:</b> <span id="summaryForm"></span>
    </div>
  </div>
  
  <div id="summaryTableContainer" style="overflow-x:auto;display:flex;justify-content:center;width:100%;"></div>
  
  <div style="text-align:center; margin:30px 0;">
    <div id="waitingMessage" class="waiting-message">
      <div>‚è≥ Waiting for Exam Time to Complete</div>
      <div class="waiting-timer" id="waitingTimer">00:00</div>
      <div>Detailed solutions will be available automatically when the exam time is over.</div>
    </div>
    <div id="autoTransitionMessage" class="auto-transition-message" style="display:none;">
      üîÑ Auto-transitioning to detailed solutions in <span id="countdown">5</span> seconds...
    </div>
    <button id="closeSummaryBtn" class="navBtn" style="background:linear-gradient(145deg, #dc3545, #c82333);">Close</button>
  </div>
</div>

<!-- Review Area -->
<div id="reviewArea">
  <div class="area-header">
    <h2>üìù Detailed Solutions - <span id="reviewStudentName"></span></h2>
    <div>
      <b>Section:</b> <span id="reviewSection"></span> | 
      <b>Roll:</b> <span id="reviewRoll"></span> | 
      <b>Admission No:</b> <span id="reviewAdm"></span> |
      <b>Form:</b> <span id="reviewForm"></span>
    </div>
  </div>
  
  <!-- Results Table in Detailed Solutions -->
  <div id="detailedResultsContainer" style="overflow-x:auto;display:flex;justify-content:center;width:100%;margin:30px 0;"></div>
  
  <div id="reviewQuestionsContainer"></div>
  
  <div style="text-align:center; margin:30px 0;">
    <button id="closeReviewBtn" class="navBtn" style="background:linear-gradient(145deg, #dc3545, #c82333);">Close</button>
  </div>
</div>

<footer>LFJC@2025 All rights reserved - 10 Form System</footer>

<div id="fullRedOverlay"></div>
<div id="accessDeniedBox">
  <h1>ACCESS DENIED</h1>
  <button id="callAdminBtn" class="glow">Enter Password</button>
</div>

<div class="confirmModal" id="confirmModal">
  <div class="confirmBox">
    <p id="confirmText">Confirm?</p>
    <button id="confirmYes">Yes</button>
    <button id="confirmNo">No</button>
  </div>
</div>

<div id="adminPassModal">
  <div id="adminPassBox">
    <h3>Enter Admin Password</h3>
    <input type="password" id="adminPassInput">
    <br><br>
    <button id="adminPassSubmit">Submit</button>
  </div>
</div>

<!-- Enhanced Screenshot Protection -->
<div id="screenshotProtection">
  <div class="screenshot-dots"></div>
</div>
<div id="screenshotBlock"></div>

<script>
// ===== CONFIGURATION =====
const MARK_PER_CORRECT = 4, MARK_PER_WRONG = -1;
const EXAM_DURATION_MINUTES = 1; // 5 minutes for testing
const EXAM_DURATION_MS = EXAM_DURATION_MINUTES * 60 * 1000;
const STORAGE_KEY_PREFIX = "lfjc_exam_";
const MAX_QUESTIONS = 60; // Maximum expected questions

// ===== ENHANCED BACKUP SYSTEM CONFIGURATION =====
let autoBackupInterval = null;
const AUTO_BACKUP_INTERVAL = 15000; // Reduced to 15 seconds for better protection
let lastBackupState = null;
let backupVersion = 0;
let isSubmitting = false; // üõë Critical: Prevent duplicate submissions

// ===== ANTI-TAB SWITCHING SYSTEM =====
let tabSwitchCount = 0;
const MAX_TAB_SWITCHES = 3;
let examStarted = false;

// ===== CRITICAL SUBMISSION LOCK =====
let submissionLock = false;
const SUBMISSION_COOLDOWN = 5000; // 5 seconds cooldown

// ===== 10-FORM CONFIGURATION =====
const GOOGLE_FORMS = {
    'A': "https://docs.google.com/forms/d/e/1FAIpQLSe4uuphhY4-p5jdTZqxG_ZZUKAhQZF1ytyNizPXb0n3L85JIw/formResponse",
    'B': "https://docs.google.com/forms/d/e/1FAIpQLSc3JIcnUysvUtH12QWpHG9wAF4vd1NgEYqeyHwNP0UEkPqi5w/formResponse", 
    'C': "https://docs.google.com/forms/d/e/1FAIpQLScqYdTGoD4l0jJvzYw0tdBNRSMPepnGtOOowOXYwDFov43KHg/formResponse",
    'D': "https://docs.google.com/forms/d/e/1FAIpQLSfjAyDlY-5BAF5rPvzQS0AeTI6Vs2Rkri0V6_miA0mRivZAEg/formResponse",
    'E': "https://docs.google.com/forms/d/e/1FAIpQLSfK6Skl6Uxj8VyGnhhqfdPHcJ8mbcgpzIKLpWFElzdeQSKMgA/formResponse",
    'F': "https://docs.google.com/forms/d/e/1FAIpQLSeP-Gx2XnUg_Q17asOOeYzkoGtLykVIcQ2W006YTqTpE7xY6g/formResponse",
    'G': "https://docs.google.com/forms/d/e/1FAIpQLSe1vg_I5XR3ljr-UNFi-MXxUgjdTDyrVbHxqi_dkvtmYGUTEA/formResponse",
    'H': "https://docs.google.com/forms/d/e/1FAIpQLScyv8cps4StN2UXrsXqNdLu5UBR7t0Vwk8WSnynU2tvracs1g/formResponse",
    'I': "https://docs.google.com/forms/d/e/1FAIpQLSeyen2hSdhRwztpWnH6lyuL91ZROqwDMKIaa4gN_e-Xvyvb_g/formResponse",
    'J': "https://docs.google.com/forms/d/e/1FAIpQLSelbDi1n1EKWu7G0I92hTML6vWUO2c55p2dqrEOQ7cWflaSNg/formResponse"
};

// DYNAMIC STUDENT DISTRIBUTION - CHANGE THIS NUMBER FOR DIFFERENT CLASS SIZES
const TOTAL_STUDENTS = 150; // Set this to 100, 150, 200, etc.

// Form field mappings - FROM YOUR PRE-FILL URL
const FORM_FIELDS = {
    STUDENT_NAME: "entry.217666919",
    SECTION: "entry.2006392966",
    ROLL_NUMBER: "entry.547275105",
    ADMISSION_NUMBER: "entry.1234063852",
    MATHS_MARKS: "entry.1989859216",
    PHYSICS_MARKS: "entry.1953974928",
    CHEMISTRY_MARKS: "entry.296331194",
    TOTAL_MARKS: "entry.1289040887",
    TIMESTAMP: "entry.2139100252"
};

// ===== GLOBAL VARIABLES =====
let images = [];
let answerKey = [];
let keyLoaded = false;
let hasSubmitted = false;
let examStartTime = null;
let waitingTimerInterval = null;
let autoTransitionTimer = null;
let examInProgress = false;
let preloadedImages = {}; // Cache for preloaded images
let currentSubjData = null; // Store subject data for detailed solutions
let assignedForm = 'A'; // Default form assignment

const subjects = ["Maths", "Physics", "Chemistry"];

let examData = {files: [], subjectNames: [], keys: [], originalOrder: []};
let progress = null, timerInterval = null;

// ===== ANTI-TAB SWITCHING SYSTEM =====
function setupTabSwitchingProtection() {
    // Detect visibility change (tab switching)
    document.addEventListener('visibilitychange', function() {
        if (examStarted && document.hidden) {
            tabSwitchCount++;
            console.log(`‚ö†Ô∏è Tab switch detected! Count: ${tabSwitchCount}`);
            
            // Show warning overlay
            document.getElementById('tabSwitchWarning').style.display = 'flex';
            
            // Auto-hide warning after 5 seconds
            setTimeout(() => {
                document.getElementById('tabSwitchWarning').style.display = 'none';
            }, 5000);
            
            // If maximum switches exceeded, auto-submit
            if (tabSwitchCount >= MAX_TAB_SWITCHES) {
                alert('üö® MAXIMUM TAB SWITCHES EXCEEDED! Auto-submitting exam...');
                submitExam();
            }
        }
    });
    
    // Prevent keyboard shortcuts for opening new tabs/windows
    document.addEventListener('keydown', function(e) {
        if (examStarted) {
            // Block Ctrl+T (new tab), Ctrl+N (new window), Ctrl+Shift+N (new incognito)
            if ((e.ctrlKey && e.key === 't') || 
                (e.ctrlKey && e.key === 'n') || 
                (e.ctrlKey && e.shiftKey && e.key === 'n')) {
                e.preventDefault();
                showTabSwitchWarning();
                return false;
            }
        }
    });
    
    // Block right-click "Open in new tab"
    document.addEventListener('contextmenu', function(e) {
        if (examStarted) {
            e.preventDefault();
            showTabSwitchWarning();
            return false;
        }
    });
}

function showTabSwitchWarning() {
    document.getElementById('tabSwitchWarning').style.display = 'flex';
    setTimeout(() => {
        document.getElementById('tabSwitchWarning').style.display = 'none';
    }, 3000);
}

// ===== FIXED ANSWER KEY LOADING =====
function loadAnswerKey() {
    console.log("üîë Loading answer key...");
    
    // Create demo answer key for testing
    console.log('üîÑ Creating demo answer key for testing...');
    answerKey = Array(60).fill().map((_, i) => ['A','B','C','D'][i % 4]);
    for (let i = 1; i <= 60; i++) {
      images.push(`questions/${i}.png`);
    }
    keyLoaded = true;
    
    console.log(`‚úÖ Demo answer key created with ${answerKey.length} answers`);
    console.log('First 10 answers:', answerKey.slice(0, 10));
    
    // Validate inputs to show start button
    validateStudentInputs();
    
    // Also try to load real key in background
    fetch('Answers/Key')
      .then(res => {
        if (!res.ok) throw new Error('Key file not found or not accessible');
        return res.text();
      })
      .then(text => {
        // Process 5-answers-per-line format correctly
        const lines = text.trim().split('\n');
        const answers = [];
        
        console.log("Processing key file with", lines.length, "lines");
        
        lines.forEach((line, lineIndex) => {
          const trimmedLine = line.trim();
          console.log(`Line ${lineIndex + 1}: "${trimmedLine}"`);
          
          if (trimmedLine) {
            // Take exactly 5 characters from each line
            for (let i = 0; i < 5 && i < trimmedLine.length; i++) {
              const char = trimmedLine[i].toUpperCase();
              
              if (['A', 'B', 'C', 'D'].includes(char)) {
                answers.push(char);
              } else {
                console.warn(`‚ö†Ô∏è Invalid answer "${trimmedLine[i]}" at line ${lineIndex + 1}, position ${i + 1}`);
              }
            }
          }
        });
        
        if (answers.length > 0) {
            answerKey = answers;
            console.log(`‚úÖ Real answer key loaded with ${answerKey.length} answers`);
        }
      })
      .catch(err => {
        console.error('‚ùå Failed to load Answers/Key:', err);
        // Keep using demo key
      });
}

// ===== FIXED STUDENT VALIDATION =====
function validateStudentInputs() {
  const n = document.getElementById('stuName'), 
        s = document.getElementById('stuSection'), 
        r = document.getElementById('stuRoll'), 
        a = document.getElementById('stuAdm');
  
  // Convert section to uppercase automatically
  if (s.value) {
    s.value = s.value.toUpperCase();
  }
  
  let v1 = /^[A-Za-z .]+$/.test(n.value), 
      v2 = /^[A-Za-z0-9]+$/.test(s.value),
      v3 = /^[0-9]+$/.test(r.value), 
      v4 = /^[0-9]+$/.test(a.value);
  
  // Show error states
  n.classList.toggle('error', !v1 && n.value !== ""); 
  s.classList.toggle('error', !v2 && s.value !== "");
  r.classList.toggle('error', !v3 && r.value !== ""); 
  a.classList.toggle('error', !v4 && a.value !== "");
  
  const startBtn = document.getElementById('stuStartBtn');
  const isValid = v1 && v2 && v3 && v4 && keyLoaded;
  
  console.log(`Validation: name=${v1}, section=${v2}, roll=${v3}, adm=${v4}, keyLoaded=${keyLoaded}, isValid=${isValid}`);
  
  if (isValid) {
    const studentData = {
      name: n.value,
      sec: s.value,
      roll: r.value,
      adm: a.value
    };
    
    // Check for duplicate sessions
    const sessionInfo = manageStudentSession(studentData);
    
    if (sessionInfo.exists) {
      // Show duplicate warning
      document.getElementById('duplicateWarning').style.display = 'block';
      startBtn.style.display = "none";
      
      // Setup force start button
      document.getElementById('forceStartBtn').onclick = function() {
        document.getElementById('duplicateWarning').style.display = 'none';
        startBtn.style.display = "inline-block";
        showConfirm("Force start exam? This may create duplicate data.", startWithSecurity);
      };
    } else {
      // No duplicate, show normal start button
      document.getElementById('duplicateWarning').style.display = 'none';
      startBtn.style.display = "inline-block";
    }
    
    updateFormAssignmentDisplay(studentData);
  } else {
    document.getElementById('formAssignment').style.display = 'none';
    document.getElementById('duplicateWarning').style.display = 'none';
    startBtn.style.display = "none";
  }
  
  // Show error if key not loaded
  if (!keyLoaded) {
    showError("Answer key not loaded - exam disabled. Contact administrator.");
  }
  
  return isValid;
}

// ===== ENHANCED DUPLICATE PREVENTION SYSTEM =====

// üõë CRITICAL: CLEAN DUPLICATE STUDENT DATA
function cleanDuplicateStudentData() {
    console.log("üßπ Cleaning duplicate student data...");
    
    const studentEntries = {};
    const keysToRemove = [];
    let cleanedCount = 0;
    
    // Scan all localStorage entries
    for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        
        // Find student entry keys (format: "name|section|roll|adm")
        if (key && key.includes('|') && !key.startsWith('exam_backup_') && !key.startsWith('submitted_') && !key.startsWith('pendingFormResults')) {
            try {
                const entry = localStorage.getItem(key);
                // If it's a timestamp (number), it's a student entry
                if (!isNaN(entry)) {
                    if (!studentEntries[key]) {
                        studentEntries[key] = entry;
                    } else {
                        // Duplicate found - mark for removal
                        keysToRemove.push(key);
                        cleanedCount++;
                    }
                }
            } catch (e) {
                console.log('Error checking key:', key);
            }
        }
    }
    
    // Remove duplicates (keep only the most recent)
    keysToRemove.forEach(key => {
        localStorage.removeItem(key);
        console.log(`üóëÔ∏è Removed duplicate: ${key}`);
    });
    
    console.log(`‚úÖ Cleaned ${cleanedCount} duplicate student entries`);
    return cleanedCount;
}

// üõë ENHANCED STUDENT SESSION MANAGEMENT
function manageStudentSession(studentData) {
    const studentKey = `${studentData.name}|${studentData.sec}|${studentData.roll}|${studentData.adm}`;
    const now = Date.now();
    const oneDayMs = 24 * 60 * 60 * 1000;
    
    // Check if student already has an active session
    const existingSession = localStorage.getItem(studentKey);
    
    if (existingSession) {
        const sessionTime = parseInt(existingSession);
        const timeDiff = now - sessionTime;
        
        if (timeDiff < oneDayMs) {
            // Session exists and is valid (less than 24 hours old)
            console.log(`üîÑ Student session exists: ${Math.round(timeDiff/1000/60)} minutes ago`);
            return {
                exists: true,
                canResume: true,
                sessionTime: sessionTime
            };
        } else {
            // Session expired - remove it
            localStorage.removeItem(studentKey);
            console.log('üóëÔ∏è Expired session removed');
        }
    }
    
    // Create new session
    localStorage.setItem(studentKey, now.toString());
    return {
        exists: false,
        canResume: false,
        sessionTime: now
    };
}

// üõë ENHANCED DUPLICATE SUBMISSION CHECK
function checkForDuplicateSubmission(studentRoll) {
    const submissions = [];
    
    // Check all forms for this student
    const forms = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J'];
    
    forms.forEach(form => {
        const submissionKey = `submitted_${studentRoll}_${form}`;
        const submission = localStorage.getItem(submissionKey);
        
        if (submission) {
            try {
                const data = JSON.parse(submission);
                submissions.push({
                    form: form,
                    timestamp: data.timestamp,
                    marks: data.marks
                });
            } catch (e) {
                console.log('Error parsing submission:', submissionKey);
            }
        }
    });
    
    return submissions;
}

// üõë CLEAN ALL DUPLICATE DATA
function cleanAllDuplicateData() {
    let totalCleaned = 0;
    
    // Clean student session duplicates
    totalCleaned += cleanDuplicateStudentData();
    
    // Clean backup duplicates
    totalCleaned += cleanOldBackups();
    
    // Clean duplicate submissions
    totalCleaned += cleanDuplicateSubmissions();
    
    alert(`‚úÖ Cleaned ${totalCleaned} duplicate entries from system!`);
    showDataRecoveryDashboard();
}

// üóëÔ∏è CLEAN EXISTING DUPLICATE SUBMISSIONS
function cleanDuplicateSubmissions() {
    console.log('üßπ Cleaning duplicate submissions...');
    const submissions = {};
    const duplicates = [];
    
    // Scan all submission entries
    for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key && key.startsWith('submitted_')) {
            try {
                const data = JSON.parse(localStorage.getItem(key));
                const studentKey = `${data.student_roll}_${data.form}`;
                
                if (!submissions[studentKey]) {
                    submissions[studentKey] = { key: key, timestamp: data.timestamp };
                } else {
                    // Keep the earliest submission, remove duplicates
                    const existingTime = new Date(submissions[studentKey].timestamp);
                    const currentTime = new Date(data.timestamp);
                    
                    if (currentTime < existingTime) {
                        duplicates.push(submissions[studentKey].key);
                        submissions[studentKey] = { key: key, timestamp: data.timestamp };
                    } else {
                        duplicates.push(key);
                    }
                }
            } catch (e) {
                console.log('Error parsing submission:', key);
            }
        }
    }
    
    // Remove duplicates
    duplicates.forEach(key => {
        localStorage.removeItem(key);
        console.log(`üóëÔ∏è Removed duplicate submission: ${key}`);
    });
    
    console.log(`‚úÖ Cleaned ${duplicates.length} duplicate submissions`);
    return duplicates.length;
}

// ===== ENHANCED BACKUP SYSTEM FUNCTIONS =====

// üõ°Ô∏è SMART PERIODIC BACKUP
function startPeriodicBackup() {
    if (autoBackupInterval) {
        clearInterval(autoBackupInterval);
    }
    
    autoBackupInterval = setInterval(() => {
        if (progress && progress.student && !isSubmitting) {
            incrementalBackup();
        }
    }, AUTO_BACKUP_INTERVAL);
}

// üß† ULTRA-EFFICIENT INCREMENTAL BACKUP
function incrementalBackup() {
    if (!progress || !progress.student || isSubmitting) return;
    
    const backupKey = `exam_backup_${progress.student.roll}`;
    const backup = JSON.parse(localStorage.getItem(backupKey) || '{}');
    
    let changesDetected = false;
    
    // Initialize backup structure if needed
    if (!backup.answers) {
        backup.answers = {};
        backup.studentInfo = progress.student;
        backup.examStartTime = examStartTime;
        backup.assignedForm = assignedForm;
        changesDetected = true;
    }
    
    // Check each answer for changes
    progress.answers.forEach((answer, index) => {
        if (answer !== null) {
            const existing = backup.answers[index];
            
            // Only backup if answer changed or is new
            if (!existing || existing.answer !== answer) {
                backup.answers[index] = {
                    answer: answer,
                    timestamp: new Date().toISOString(),
                    questionFile: examData.files[index],
                    subject: examData.subjectNames[index],
                    version: backupVersion
                };
                changesDetected = true;
                console.log(`üíæ Backup Q${index+1}: ${answer}`);
            }
        }
    });
    
    if (changesDetected) {
        backupVersion++;
        backup.lastBackup = new Date().toISOString();
        backup.backupVersion = backupVersion;
        
        // üõ°Ô∏è CRITICAL: Save with error handling
        try {
            localStorage.setItem(backupKey, JSON.stringify(backup));
            console.log(`üîÑ Smart backup v${backupVersion} - ${Object.keys(backup.answers).length} answers`);
            updateBackupStatus();
        } catch (error) {
            console.error('‚ùå Backup failed:', error);
            // Try to clear space and retry
            clearOldBackups();
        }
    } else {
        console.log(`‚è∞ No changes - skipping backup (v${backupVersion})`);
    }
    
    return changesDetected;
}

// üóëÔ∏è CLEAR OLD BACKUPS TO PREVENT STORAGE FULL ERRORS
function clearOldBackups() {
    const now = Date.now();
    const oneDayAgo = now - (24 * 60 * 60 * 1000);
    let cleanedCount = 0;
    
    for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key && key.startsWith('exam_backup_')) {
            try {
                const backup = JSON.parse(localStorage.getItem(key));
                if (backup && backup.lastBackup) {
                    const backupTime = new Date(backup.lastBackup).getTime();
                    if (backupTime < oneDayAgo) {
                        localStorage.removeItem(key);
                        console.log(`üßπ Cleared old backup: ${key}`);
                        cleanedCount++;
                    }
                }
            } catch (e) {
                // Remove corrupted backups
                localStorage.removeItem(key);
                cleanedCount++;
            }
        }
    }
    
    return cleanedCount;
}

// üõ°Ô∏è EMERGENCY BACKUP ON PAGE UNLOAD
window.addEventListener('beforeunload', function(e) {
    if (progress && !hasSubmitted && !isSubmitting) {
        // üõ°Ô∏è LAST-MINUTE BACKUP BEFORE PAGE UNLOADS
        progress.answers.forEach((answer, index) => {
            if (answer !== null) {
                backupAnswerToLocal(index, answer);
            }
        });
        console.log('üõ°Ô∏è Emergency backup before page unload');
    }
});

// üõ°Ô∏è ENHANCED RECOVERY FUNCTION
function recoverExamFromBackup(studentRoll) {
    const backupKey = `exam_backup_${studentRoll}`;
    const backup = JSON.parse(localStorage.getItem(backupKey) || '{}');
    
    if (!backup.studentInfo || !backup.answers) {
        alert('No recoverable exam data found.');
        return false;
    }
    
    // Check if exam was already submitted
    if (checkIfAlreadySubmitted(studentRoll, backup.assignedForm)) {
        showConfirm(
            "This exam was already submitted. Resume anyway?",
            (resume) => {
                if (resume) {
                    proceedWithRecovery(backup, studentRoll);
                }
            }
        );
    } else {
        proceedWithRecovery(backup, studentRoll);
    }
}

function proceedWithRecovery(backup, studentRoll) {
    // Restore progress from backup
    progress = {
        answers: Array(examData.files.length).fill(null),
        review: Array(examData.files.length).fill(false),
        currentIndex: 0,
        student: backup.studentInfo,
        timeLeftSec: EXAM_DURATION_MINUTES * 60
    };
    
    // Restore answers from backup
    Object.keys(backup.answers).forEach(qIndex => {
        const index = parseInt(qIndex);
        if (index >= 0 && index < progress.answers.length) {
            progress.answers[index] = backup.answers[qIndex].answer;
        }
    });
    
    assignedForm = backup.assignedForm || 'A';
    
    // Calculate remaining time
    const examStartTime = backup.examStartTime ? new Date(backup.examStartTime).getTime() : Date.now();
    const timeElapsed = Date.now() - examStartTime;
    const timeRemaining = EXAM_DURATION_MS - timeElapsed;
    
    if (timeRemaining > 0) {
        progress.timeLeftSec = Math.floor(timeRemaining / 1000);
    } else {
        progress.timeLeftSec = 0;
    }
    
    // Resume exam
    document.getElementById('studentEntry').style.display = "none";
    document.getElementById('examArea').style.display = "block";
    renderQuestion(); 
    renderPalette(); 
    startTimer(); 
    updateNavButtons();
    startPeriodicBackup(); // üõ°Ô∏è Restart periodic backup
    
    const recoveredCount = Object.keys(backup.answers).length;
    console.log(`‚úÖ Exam recovered for ${progress.student.name}! ${recoveredCount} answers restored.`);
}

// ===== DUPLICATE PREVENTION FUNCTIONS =====

// üõë CHECK IF ALREADY SUBMITTED
function checkIfAlreadySubmitted(studentRoll, form) {
    const submissionKey = `submitted_${studentRoll}_${form}`;
    const existing = localStorage.getItem(submissionKey);
    
    if (existing) {
        const data = JSON.parse(existing);
        console.log(`üìã Student ${studentRoll} already submitted to Form ${form} at ${data.timestamp}`);
        return true;
    }
    return false;
}

// üõë MARK AS SUBMITTED
function markAsSubmitted(studentRoll, form, marks) {
    const submissionKey = `submitted_${studentRoll}_${form}`;
    localStorage.setItem(submissionKey, JSON.stringify({
        submitted: true,
        timestamp: new Date().toISOString(),
        marks: marks,
        student_roll: studentRoll,
        form: form
    }));
    console.log(`‚úÖ Marked ${studentRoll} as submitted to Form ${form}`);
}

// ===== DATA PROTECTION FUNCTIONS =====

// üõ°Ô∏è REAL-TIME ANSWER BACKUP
function backupAnswerToLocal(questionIndex, answer) {
    if (!progress || !progress.student) return;
    
    const backupKey = `exam_backup_${progress.student.roll}`;
    const backup = JSON.parse(localStorage.getItem(backupKey) || '{}');
    
    // Initialize backup structure
    backup.answers = backup.answers || {};
    backup.studentInfo = progress.student;
    backup.examStartTime = examStartTime;
    backup.lastBackup = new Date().toISOString();
    backup.assignedForm = assignedForm;
    
    // Store answer with timestamp
    backup.answers[questionIndex] = {
        answer: answer,
        timestamp: new Date().toISOString(),
        questionFile: examData.files[questionIndex],
        subject: examData.subjectNames[questionIndex]
    };
    
    // Save to localStorage
    localStorage.setItem(backupKey, JSON.stringify(backup));
    
    // Update backup status display
    updateBackupStatus();
    
    console.log(`üíæ Backed up Q${questionIndex+1}: ${answer} for ${progress.student.roll}`);
}

// üõ°Ô∏è VALIDATE BACKUP BEFORE SUBMISSION
function validateBackupBeforeSubmission() {
    if (!progress) return { isValid: false, message: "No progress data" };
    
    const backupKey = `exam_backup_${progress.student.roll}`;
    const backup = JSON.parse(localStorage.getItem(backupKey) || '{}');
    
    const answeredInBackup = Object.keys(backup.answers || {}).length;
    const answeredInMemory = progress.answers.filter(a => a !== null).length;
    
    console.log(`üîç Backup Validation: ${answeredInBackup} in backup vs ${answeredInMemory} in memory`);
    
    if (answeredInBackup === 0 && answeredInMemory === 0) {
        return { isValid: true, message: "No answers to backup" };
    }
    
    if (answeredInBackup >= answeredInMemory) {
        return { 
            isValid: true, 
            message: `Backup complete (${answeredInBackup}/${progress.answers.length} answers)` 
        };
    } else {
        return { 
            isValid: false, 
            message: `Backup incomplete: ${answeredInBackup} in backup vs ${answeredInMemory} in memory` 
        };
    }
}

// üõ°Ô∏è UPDATE BACKUP STATUS DISPLAY
function updateBackupStatus() {
    if (!progress) return;
    
    const backupKey = `exam_backup_${progress.student.roll}`;
    const backup = JSON.parse(localStorage.getItem(backupKey) || '{}');
    const answeredCount = Object.keys(backup.answers || {}).length;
    
    const statusElement = document.getElementById('backupStatus');
    if (statusElement) {
        statusElement.innerHTML = `üíæ Auto-backup active - ${answeredCount}/${progress.answers.length} answers secured`;
        
        // Visual feedback
        statusElement.style.background = answeredCount > 0 ? '#d4edda' : '#fff3cd';
        statusElement.style.borderColor = answeredCount > 0 ? '#c3e6cb' : '#ffeaa7';
    }
}

// üõ°Ô∏è RECOVERY DASHBOARD FUNCTIONS
function showDataRecoveryDashboard() {
    const pendingResults = JSON.parse(localStorage.getItem('pendingFormResults') || '[]');
    
    // Count active backups and successful submissions
    let backupCount = 0;
    let successCount = 0;
    for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key && key.startsWith('exam_backup_')) {
            backupCount++;
        }
        if (key && key.startsWith('submitted_')) {
            successCount++;
        }
    }
    
    document.getElementById('pendingCount').textContent = pendingResults.length;
    document.getElementById('backupCount').textContent = backupCount;
    document.getElementById('successCount').textContent = successCount;
    document.getElementById('dataRecoveryDashboard').style.display = 'block';
}

function exportAllBackupData() {
    const backupData = {};
    
    // Collect all backups and submissions
    for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key && (key.startsWith('exam_backup_') || key.startsWith('pendingFormResults') || key.startsWith('submitted_'))) {
            backupData[key] = JSON.parse(localStorage.getItem(key));
        }
    }
    
    // Create download
    const dataStr = JSON.stringify(backupData, null, 2);
    const dataBlob = new Blob([dataStr], {type: 'application/json'});
    const url = URL.createObjectURL(dataBlob);
    const link = document.createElement('a');
    link.href = url;
    link.download = `exam_backup_${new Date().toISOString().split('T')[0]}.json`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
    
    alert('üì• All backup data exported successfully!');
}

function retryFailedSubmissions() {
    const pendingResults = JSON.parse(localStorage.getItem('pendingFormResults') || '[]');
    if (pendingResults.length === 0) {
        alert('No pending submissions to retry.');
        return;
    }
    
    showConfirm(`Retry ${pendingResults.length} failed submissions?`, (confirmed) => {
        if (confirmed) {
            alert('üîÑ Retry functionality would be implemented here with proper server connection.');
            // Implementation would involve re-sending all pending results
        }
    });
}

function clearAllSubmissions() {
    showConfirm("üóëÔ∏è Clear ALL submission records? This cannot be undone!", (confirmed) => {
        if (confirmed) {
            // Remove all submission records
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key && key.startsWith('submitted_')) {
                    localStorage.removeItem(key);
                }
            }
            alert('‚úÖ All submission records cleared!');
            showDataRecoveryDashboard();
        }
    });
}

// ===== NETWORK FAILURE PROTECTION =====

// üõ°Ô∏è OFFLINE SUBMISSION QUEUE
function processOfflineSubmissions() {
    if (!navigator.onLine) return;
    
    const pendingResults = JSON.parse(localStorage.getItem('pendingFormResults') || '[]');
    if (pendingResults.length === 0) return;
    
    console.log(`üîÑ Processing ${pendingResults.length} offline submissions...`);
    
    // Process each pending submission
    pendingResults.forEach(async (result, index) => {
        if (!result.submitted_to_google && !result.duplicate_prevented) {
            // Retry submission logic here
            console.log(`Retrying submission for ${result.student_name}`);
        }
    });
}

// üõ°Ô∏è NETWORK STATUS MONITORING
window.addEventListener('online', function() {
    console.log('üåê Network connection restored');
    const networkStatus = document.getElementById('networkStatus');
    if (networkStatus) {
        networkStatus.style.display = 'none';
    }
    processOfflineSubmissions();
});

window.addEventListener('offline', function() {
    console.log('üìµ Network connection lost - operating in offline mode');
    const networkStatus = document.getElementById('networkStatus');
    if (networkStatus) {
        networkStatus.style.display = 'block';
    }
});

// ===== PERFECT FORM ASSIGNMENT FUNCTIONS =====
function getAssignedForm(studentData) {
    const forms = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J'];
    const formsCount = forms.length;
    
    // Method 1: Perfect roll number based distribution
    if (studentData.roll && !isNaN(studentData.roll)) {
        const rollNumber = parseInt(studentData.roll);
        
        // Dynamic calculation based on actual total students
        const studentsPerForm = Math.ceil(TOTAL_STUDENTS / formsCount);
        
        // Perfect distribution formula
        const formIndex = Math.floor((rollNumber - 1) / studentsPerForm) % formsCount;
        return forms[formIndex];
    }
    
    // Method 2: Consistent hash-based fallback
    const hashString = `${studentData.name}|${studentData.roll}|${studentData.adm}`;
    let hash = 0;
    for (let i = 0; i < hashString.length; i++) {
        hash = ((hash << 5) - hash) + hashString.charCodeAt(i);
        hash = hash & hash; // Convert
  // ===== PERFECT FORM ASSIGNMENT FUNCTIONS =====
function getAssignedForm(studentData) {
    const forms = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J'];
    const formsCount = forms.length;
    
    // Method 1: Perfect roll number based distribution
    if (studentData.roll && !isNaN(studentData.roll)) {
        const rollNumber = parseInt(studentData.roll);
        
        // Dynamic calculation based on actual total students
        const studentsPerForm = Math.ceil(TOTAL_STUDENTS / formsCount);
        
        // Perfect distribution formula
        const formIndex = Math.floor((rollNumber - 1) / studentsPerForm) % formsCount;
        return forms[formIndex];
    }
    
    // Method 2: Consistent hash-based fallback
    const hashString = `${studentData.name}|${studentData.roll}|${studentData.adm}`;
    let hash = 0;
    for (let i = 0; i < hashString.length; i++) {
        hash = ((hash << 5) - hash) + hashString.charCodeAt(i);
        hash = hash & hash; // Convert to 32-bit integer
    }
    
    const formIndex = Math.abs(hash) % formsCount;
    return forms[formIndex];
}

function updateFormAssignmentDisplay(studentData) {
    assignedForm = getAssignedForm(studentData);
    document.getElementById('assignedFormDisplay').textContent = `FORM ${assignedForm}`;
    document.getElementById('formAssignment').style.display = 'block';
}

// ===== EXAM START WITH SECURITY =====
function startWithSecurity() {
    const studentData = {
        name: document.getElementById('stuName').value.trim(),
        sec: document.getElementById('stuSection').value.trim(),
        roll: document.getElementById('stuRoll').value.trim(),
        adm: document.getElementById('stuAdm').value.trim()
    };
    
    // Check for existing submission
    const existingSubmissions = checkForDuplicateSubmission(studentData.roll);
    if (existingSubmissions.length > 0) {
        showConfirm(
            `Student ${studentData.roll} already has submissions. Start new exam?`,
            function(confirmed) {
                if (confirmed) {
                    initializeExam(studentData);
                }
            }
        );
    } else {
        initializeExam(studentData);
    }
}

function initializeExam(studentData) {
    // Initialize exam progress
    progress = {
        answers: Array(images.length).fill(null),
        review: Array(images.length).fill(false),
        currentIndex: 0,
        student: studentData,
        timeLeftSec: EXAM_DURATION_MINUTES * 60
    };
    
    examStartTime = Date.now();
    examStarted = true;
    examInProgress = true;
    
    // Show exam area
    document.getElementById('studentEntry').style.display = "none";
    document.getElementById('examArea').style.display = "block";
    document.getElementById('examWarning').style.display = "block";
    
    // Initialize UI
    renderQuestion();
    renderPalette();
    startTimer();
    updateNavButtons();
    
    // Start security systems
    startPeriodicBackup();
    setupTabSwitchingProtection();
    
    console.log(`‚úÖ Exam started for ${studentData.name}, Form: ${assignedForm}`);
}

// ===== QUESTION RENDERING =====
function renderQuestion() {
    if (!progress) return;
    
    const container = document.getElementById('questionContainer');
    const idx = progress.currentIndex;
    
    container.innerHTML = `
        <div class="sectionTitle">${examData.subjectNames[idx] || 'Question'} ${idx + 1}</div>
        <img src="${images[idx]}" class="questionImg" alt="Question ${idx + 1}" 
             onerror="handleImageError(this, ${idx})" 
             onload="handleImageLoad(this)">
        <div class="options-container">
            <button class="optBtn" data-opt="A">A</button>
            <button class="optBtn" data-opt="B">B</button>
            <button class="optBtn" data-opt="C">C</button>
            <button class="optBtn" data-opt="D">D</button>
        </div>
    `;
    
    // Set current answer if exists
    const currentAnswer = progress.answers[idx];
    if (currentAnswer) {
        const btn = container.querySelector(`[data-opt="${currentAnswer}"]`);
        if (btn) btn.classList.add('selected');
    }
    
    // Add event listeners to options
    container.querySelectorAll('.optBtn').forEach(btn => {
        btn.addEventListener('click', function() {
            selectOption(this.getAttribute('data-opt'));
        });
    });
    
    // Update student info
    document.getElementById('stuInfo').textContent = 
        `${progress.student.name} | ${progress.student.sec} | Roll: ${progress.student.roll}`;
    document.getElementById('stuQInfo').textContent = 
        `Question: ${idx + 1} of ${images.length}`;
        
    updatePalette();
}

function handleImageError(img, index) {
    console.error(`‚ùå Failed to load image: ${images[index]}`);
    img.alt = `Question ${index + 1} image failed to load`;
    img.style.display = 'none';
    
    const container = img.parentElement;
    const errorDiv = document.createElement('div');
    errorDiv.className = 'image-error';
    errorDiv.innerHTML = `
        <h3>üìÑ Question ${index + 1}</h3>
        <p>Image temporarily unavailable</p>
        <p><em>Please continue with other questions</em></p>
    `;
    container.insertBefore(errorDiv, img.nextSibling);
}

function handleImageLoad(img) {
    img.classList.add('question-fade-in');
}

// ===== OPTION SELECTION =====
function selectOption(opt) {
    if (!progress) return;
    
    const idx = progress.currentIndex;
    progress.answers[idx] = opt;
    
    // Update UI
    const container = document.getElementById('questionContainer');
    container.querySelectorAll('.optBtn').forEach(btn => {
        btn.classList.remove('selected');
    });
    
    const selectedBtn = container.querySelector(`[data-opt="${opt}"]`);
    if (selectedBtn) selectedBtn.classList.add('selected');
    
    // Backup answer immediately
    backupAnswerToLocal(idx, opt);
    updatePalette();
}

// ===== PALETTE FUNCTIONS =====
function renderPalette() {
    const container = document.getElementById('paletteContainer');
    container.innerHTML = '';
    
    for (let i = 0; i < images.length; i++) {
        const btn = document.createElement('button');
        btn.textContent = i + 1;
        btn.addEventListener('click', () => gotoQuestion(i));
        
        if (i === progress.currentIndex) {
            btn.classList.add('current');
        }
        if (progress.answers[i]) {
            btn.classList.add('selected');
        }
        if (progress.review[i]) {
            btn.classList.add('reviewed');
        }
        
        container.appendChild(btn);
    }
}

function updatePalette() {
    const buttons = document.getElementById('paletteContainer').children;
    
    for (let i = 0; i < buttons.length; i++) {
        const btn = buttons[i];
        btn.classList.remove('current', 'selected', 'reviewed');
        
        if (i === progress.currentIndex) {
            btn.classList.add('current');
        }
        if (progress.answers[i]) {
            btn.classList.add('selected');
        }
        if (progress.review[i]) {
            btn.classList.add('reviewed');
        }
    }
}

function gotoQuestion(index) {
    if (!progress || index < 0 || index >= images.length) return;
    
    progress.currentIndex = index;
    renderQuestion();
    updateNavButtons();
}

// ===== NAVIGATION FUNCTIONS =====
function updateNavButtons() {
    if (!progress) return;
    
    const idx = progress.currentIndex;
    document.getElementById('prevBtn').disabled = idx === 0;
    document.getElementById('nextBtn').disabled = idx === images.length - 1;
    
    // Update mark review button
    const reviewBtn = document.getElementById('markReviewBtn');
    if (progress.review[idx]) {
        reviewBtn.textContent = "Unmark Review";
        reviewBtn.style.background = "linear-gradient(145deg, #32CD32, #228B22)";
    } else {
        reviewBtn.textContent = "Mark for Review";
        reviewBtn.style.background = "linear-gradient(145deg, #ffb84d, var(--warning))";
    }
}

document.getElementById('prevBtn').addEventListener('click', () => {
    if (progress.currentIndex > 0) {
        progress.currentIndex--;
        renderQuestion();
        updateNavButtons();
    }
});

document.getElementById('nextBtn').addEventListener('click', () => {
    if (progress.currentIndex < images.length - 1) {
        progress.currentIndex++;
        renderQuestion();
        updateNavButtons();
    }
});

document.getElementById('markReviewBtn').addEventListener('click', () => {
    if (!progress) return;
    
    const idx = progress.currentIndex;
    progress.review[idx] = !progress.review[idx];
    updateNavButtons();
    updatePalette();
});

// ===== TIMER FUNCTIONS =====
function startTimer() {
    if (timerInterval) clearInterval(timerInterval);
    
    timerInterval = setInterval(() => {
        if (!progress) return;
        
        progress.timeLeftSec--;
        
        if (progress.timeLeftSec <= 0) {
            clearInterval(timerInterval);
            autoSubmitExam();
            return;
        }
        
        updateTimerDisplay();
        
        // Warning when 5 minutes left
        if (progress.timeLeftSec === 300) {
            showTimeWarning(5);
        }
        // Warning when 1 minute left  
        else if (progress.timeLeftSec === 60) {
            showTimeWarning(1);
        }
        // Blink when 30 seconds left
        else if (progress.timeLeftSec <= 30) {
            document.getElementById('timerEl').classList.add('blink');
        }
    }, 1000);
    
    updateTimerDisplay();
}

function updateTimerDisplay() {
    if (!progress) return;
    
    const minutes = Math.floor(progress.timeLeftSec / 60);
    const seconds = progress.timeLeftSec % 60;
    const timerEl = document.getElementById('timerEl');
    
    timerEl.textContent = `üïí ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    
    // Color coding
    timerEl.style.background = progress.timeLeftSec <= 60 ? '#ff6666' : '#f0f0ff';
    timerEl.style.color = progress.timeLeftSec <= 60 ? 'white' : 'var(--primary-color)';
}

function showTimeWarning(minutes) {
    const warning = document.createElement('div');
    warning.className = 'warning-banner';
    warning.innerHTML = `‚è∞ <strong>Time Warning:</strong> Only ${minutes} minute${minutes > 1 ? 's' : ''} remaining!`;
    warning.style.animation = 'pulse 1s infinite';
    
    document.getElementById('examArea').insertBefore(warning, document.getElementById('questionContainer'));
    
    setTimeout(() => {
        if (warning.parentNode) {
            warning.parentNode.removeChild(warning);
        }
    }, 10000);
}

// ===== EXAM SUBMISSION SYSTEM =====
function submitExam() {
    if (isSubmitting) {
        console.log('üõë Submission already in progress');
        return;
    }
    
    showConfirm("Submit exam? This action cannot be undone.", (confirmed) => {
        if (confirmed) {
            processExamSubmission();
        }
    });
}

document.getElementById('submitBtn').addEventListener('click', submitExam);

async function processExamSubmission() {
    isSubmitting = true;
    
    try {
        // Final backup before submission
        incrementalBackup();
        
        // Validate backup
        const backupValidation = validateBackupBeforeSubmission();
        if (!backupValidation.isValid) {
            console.warn('‚ö†Ô∏è Backup validation warning:', backupValidation.message);
        }
        
        // Calculate results
        const results = calculateResults();
        
        // Submit to Google Form
        const submissionSuccess = await submitToGoogleForm(results);
        
        if (submissionSuccess) {
            // Mark as successfully submitted
            markAsSubmitted(progress.student.roll, assignedForm, results.totalMarks);
            
            // Clear backup data
            const backupKey = `exam_backup_${progress.student.roll}`;
            localStorage.removeItem(backupKey);
            
            // Show success and summary
            showExamSummary(results);
            hasSubmitted = true;
        } else {
            // Store for offline retry
            storeOfflineSubmission(results);
            showExamSummary(results);
        }
        
    } catch (error) {
        console.error('‚ùå Submission error:', error);
        alert('Submission failed but answers are saved. Contact administrator.');
        showExamSummary(calculateResults());
    } finally {
        isSubmitting = false;
        examInProgress = false;
    }
}

function autoSubmitExam() {
    if (hasSubmitted) return;
    
    console.log('‚è∞ Auto-submitting exam due to time limit');
    processExamSubmission();
}

// ===== RESULTS CALCULATION =====
function calculateResults() {
    if (!progress || !answerKey) return null;
    
    let correct = 0, wrong = 0, unattempted = 0;
    const questionResults = [];
    
    for (let i = 0; i < Math.min(progress.answers.length, answerKey.length); i++) {
        const studentAnswer = progress.answers[i];
        const correctAnswer = answerKey[i];
        
        let status, marks = 0;
        
        if (!studentAnswer) {
            status = 'not-attempted';
            unattempted++;
        } else if (studentAnswer === correctAnswer) {
            status = 'correct';
            marks = MARK_PER_CORRECT;
            correct++;
        } else {
            status = 'wrong';
            marks = MARK_PER_WRONG;
            wrong++;
        }
        
        questionResults.push({
            questionNo: i + 1,
            studentAnswer: studentAnswer,
            correctAnswer: correctAnswer,
            status: status,
            marks: marks,
            subject: examData.subjectNames[i] || 'Unknown'
        });
    }
    
    const totalMarks = (correct * MARK_PER_CORRECT) + (wrong * MARK_PER_WRONG);
    
    return {
        student: progress.student,
        assignedForm: assignedForm,
        correct: correct,
        wrong: wrong,
        unattempted: unattempted,
        totalMarks: totalMarks,
        questionResults: questionResults,
        timestamp: new Date().toISOString()
    };
}

// ===== GOOGLE FORM SUBMISSION =====
async function submitToGoogleForm(results) {
    if (!navigator.onLine) {
        console.log('üìµ Offline - storing submission for later');
        return false;
    }
    
    try {
        const formData = new FormData();
        
        // Add form fields based on your Google Form structure
        formData.append(FORM_FIELDS.STUDENT_NAME, results.student.name);
        formData.append(FORM_FIELDS.SECTION, results.student.sec);
        formData.append(FORM_FIELDS.ROLL_NUMBER, results.student.roll);
        formData.append(FORM_FIELDS.ADMISSION_NUMBER, results.student.adm);
        formData.append(FORM_FIELDS.MATHS_MARKS, results.totalMarks); // Adjust based on actual subjects
        formData.append(FORM_FIELDS.PHYSICS_MARKS, results.totalMarks);
        formData.append(FORM_FIELDS.CHEMISTRY_MARKS, results.totalMarks);
        formData.append(FORM_FIELDS.TOTAL_MARKS, results.totalMarks);
        formData.append(FORM_FIELDS.TIMESTAMP, new Date().toISOString());
        
        const response = await fetch(GOOGLE_FORMS[assignedForm], {
            method: 'POST',
            body: formData,
            mode: 'no-cors'
        });
        
        console.log('‚úÖ Submitted to Google Form:', assignedForm);
        return true;
        
    } catch (error) {
        console.error('‚ùå Google Form submission failed:', error);
        return false;
    }
}

function storeOfflineSubmission(results) {
    const pendingResults = JSON.parse(localStorage.getItem('pendingFormResults') || '[]');
    results.submitted_to_google = false;
    results.duplicate_prevented = true;
    pendingResults.push(results);
    
    localStorage.setItem('pendingFormResults', JSON.stringify(pendingResults));
    console.log('üíæ Stored offline submission for retry');
}

// ===== EXAM SUMMARY =====
function showExamSummary(results) {
    if (!results) return;
    
    // Stop timers and cleanup
    clearInterval(timerInterval);
    clearInterval(autoBackupInterval);
    
    // Update summary display
    document.getElementById('summaryStudentName').textContent = results.student.name;
    document.getElementById('summarySection').textContent = results.student.sec;
    document.getElementById('summaryRoll').textContent = results.student.roll;
    document.getElementById('summaryAdm').textContent = results.student.adm;
    document.getElementById('summaryForm').textContent = assignedForm;
    
    // Create results table
    const tableContainer = document.getElementById('summaryTableContainer');
    tableContainer.innerHTML = `
        <table class="results-table">
            <tr><th>Subject</th><th>Correct</th><th>Wrong</th><th>Unattempted</th><th>Marks</th></tr>
            <tr>
                <td>Total</td>
                <td>${results.correct}</td>
                <td>${results.wrong}</td>
                <td>${results.unattempted}</td>
                <td><strong>${results.totalMarks}</strong></td>
            </tr>
        </table>
    `;
    
    // Show summary area
    document.getElementById('examArea').style.display = "none";
    document.getElementById('summaryArea').style.display = "block";
    
    // Start waiting timer for detailed solutions
    startWaitingTimer();
}

function startWaitingTimer() {
    const examEndTime = examStartTime + EXAM_DURATION_MS;
    const now = Date.now();
    const timeUntilEnd = examEndTime - now;
    
    if (timeUntilEnd <= 0) {
        // Exam time already over, show transition immediately
        showAutoTransition();
        return;
    }
    
    // Update waiting timer
    const waitingTimerEl = document.getElementById('waitingTimer');
    const updateWaitingTimer = () => {
        const remaining = Math.max(0, examEndTime - Date.now());
        const minutes = Math.floor(remaining / 60000);
        const seconds = Math.floor((remaining % 60000) / 1000);
        waitingTimerEl.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        
        if (remaining <= 0) {
            clearInterval(waitingTimerInterval);
            showAutoTransition();
        }
    };
    
    updateWaitingTimer();
    waitingTimerInterval = setInterval(updateWaitingTimer, 1000);
}

function showAutoTransition() {
    document.getElementById('waitingMessage').style.display = 'none';
    document.getElementById('autoTransitionMessage').style.display = 'block';
    
    let countdown = 5;
    const countdownEl = document.getElementById('countdown');
    
    autoTransitionTimer = setInterval(() => {
        countdown--;
        countdownEl.textContent = countdown;
        
        if (countdown <= 0) {
            clearInterval(autoTransitionTimer);
            showDetailedSolutions();
        }
    }, 1000);
}

// ===== DETAILED SOLUTIONS =====
function showDetailedSolutions() {
    const results = calculateResults();
    if (!results) return;
    
    // Update review display
    document.getElementById('reviewStudentName').textContent = results.student.name;
    document.getElementById('reviewSection').textContent = results.student.sec;
    document.getElementById('reviewRoll').textContent = results.student.roll;
    document.getElementById('reviewAdm').textContent = results.student.adm;
    document.getElementById('reviewForm').textContent = assignedForm;
    
    // Create detailed results table
    const detailedContainer = document.getElementById('detailedResultsContainer');
    detailedContainer.innerHTML = createDetailedResultsTable(results);
    
    // Create question-by-question review
    const reviewContainer = document.getElementById('reviewQuestionsContainer');
    reviewContainer.innerHTML = createQuestionReview(results);
    
    // Show review area
    document.getElementById('summaryArea').style.display = "none";
    document.getElementById('reviewArea').style.display = "block";
}

function createDetailedResultsTable(results) {
    // Group by subject
    const subjectStats = {};
    results.questionResults.forEach(q => {
        if (!subjectStats[q.subject]) {
            subjectStats[q.subject] = { correct: 0, wrong: 0, unattempted: 0, marks: 0 };
        }
        
        const stats = subjectStats[q.subject];
        if (q.status === 'correct') {
            stats.correct++;
            stats.marks += MARK_PER_CORRECT;
        } else if (q.status === 'wrong') {
            stats.wrong++;
            stats.marks += MARK_PER_WRONG;
        } else {
            stats.unattempted++;
        }
    });
    
    let tableHTML = `
        <table class="detailed-results-table">
            <tr>
                <th>Subject</th>
                <th>Correct</th>
                <th>Wrong</th>
                <th>Unattempted</th>
                <th>Marks</th>
            </tr>
    `;
    
    // Add subject rows
    Object.keys(subjectStats).forEach(subject => {
        const stats = subjectStats[subject];
        tableHTML += `
            <tr>
                <td>${subject}</td>
                <td>${stats.correct}</td>
                <td>${stats.wrong}</td>
                <td>${stats.unattempted}</td>
                <td>${stats.marks}</td>
            </tr>
        `;
    });
    
    // Add total row
    tableHTML += `
        <tr class="total-row">
            <td><strong>TOTAL</strong></td>
            <td><strong>${results.correct}</strong></td>
            <td><strong>${results.wrong}</strong></td>
            <td><strong>${results.unattempted}</strong></td>
            <td><strong>${results.totalMarks}</strong></td>
        </tr>
    </table>`;
    
    return tableHTML;
}

function createQuestionReview(results) {
    let reviewHTML = '<div class="area-header"><h3>üìù Question-wise Analysis</h3></div>';
    
    results.questionResults.forEach(q => {
        const statusClass = `answer-status ${q.status}`;
        const statusText = q.status === 'correct' ? '‚úì Correct' : 
                          q.status === 'wrong' ? '‚úó Wrong' : '‚óã Not Attempted';
        
        reviewHTML += `
            <div class="question-review" style="margin: 20px 0; padding: 15px; border: 1px solid #ddd; border-radius: 8px;">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <h4>Question ${q.questionNo} - ${q.subject}</h4>
                    <div class="${statusClass}">${statusText} (${q.marks > 0 ? '+' : ''}${q.marks})</div>
                </div>
                <div style="margin-top: 10px;">
                    <p><strong>Your Answer:</strong> ${q.studentAnswer || 'Not attempted'}</p>
                    <p><strong>Correct Answer:</strong> <span class="correct-answer">${q.correctAnswer}</span></p>
                </div>
            </div>
        `;
    });
    
    return reviewHTML;
}

// ===== MODAL AND UI CONTROLS =====
function showConfirm(message, callback) {
    const modal = document.getElementById('confirmModal');
    const text = document.getElementById('confirmText');
    const yesBtn = document.getElementById('confirmYes');
    const noBtn = document.getElementById('confirmNo');
    
    text.textContent = message;
    modal.style.display = 'flex';
    
    const cleanup = () => {
        modal.style.display = 'none';
        yesBtn.onclick = null;
        noBtn.onclick = null;
    };
    
    yesBtn.onclick = () => {
        cleanup();
        callback(true);
    };
    
    noBtn.onclick = () => {
        cleanup();
        callback(false);
    };
}

function showError(message) {
    const errorDiv = document.getElementById('errorMessages');
    errorDiv.innerHTML = `<div class="error-message">${message}</div>`;
    setTimeout(() => { errorDiv.innerHTML = ''; }, 5000);
}

// ===== CLOSE BUTTON HANDLERS =====
document.getElementById('closeSummaryBtn').addEventListener('click', () => {
    document.getElementById('summaryArea').style.display = "none";
    document.getElementById('studentEntry').style.display = "flex";
    resetExam();
});

document.getElementById('closeReviewBtn').addEventListener('click', () => {
    document.getElementById('reviewArea').style.display = "none";
    document.getElementById('studentEntry').style.display = "flex";
    resetExam();
});

function resetExam() {
    progress = null;
    examStarted = false;
    examInProgress = false;
    hasSubmitted = false;
    isSubmitting = false;
    
    clearInterval(timerInterval);
    clearInterval(autoBackupInterval);
    clearInterval(waitingTimerInterval);
    clearInterval(autoTransitionTimer);
    
    // Clear form inputs
    document.getElementById('stuName').value = '';
    document.getElementById('stuSection').value = '';
    document.getElementById('stuRoll').value = '';
    document.getElementById('stuAdm').value = '';
    
    document.getElementById('examWarning').style.display = 'none';
    document.getElementById('resumeExamSection').style.display = 'none';
}

// ===== ADMIN FUNCTIONS =====
document.getElementById('callAdminBtn').addEventListener('click', () => {
    document.getElementById('adminPassModal').style.display = 'flex';
});

document.getElementById('adminPassSubmit').addEventListener('click', () => {
    const password = document.getElementById('adminPassInput').value;
    // Add your admin password check here
    if (password === 'admin123') { // Change this to your actual password
        document.getElementById('adminPassModal').style.display = 'none';
        document.getElementById('fullRedOverlay').style.display = 'none';
        document.getElementById('accessDeniedBox').style.display = 'none';
        showDataRecoveryDashboard();
    } else {
        alert('Incorrect password!');
    }
});

// ===== INITIALIZATION =====
document.addEventListener('DOMContentLoaded', function() {
    console.log('üöÄ Initializing LFJC Online Exam System...');
    
    // Load answer key
    loadAnswerKey();
    
    // Setup event listeners for student inputs
    const inputs = ['stuName', 'stuSection', 'stuRoll', 'stuAdm'];
    inputs.forEach(id => {
        document.getElementById(id).addEventListener('input', validateStudentInputs);
    });
    
    // Start button
    document.getElementById('stuStartBtn').addEventListener('click', startWithSecurity);
    
    // Check for existing exam to resume
    checkForResumableExam();
    
    // Initialize network status
    if (!navigator.onLine) {
        document.getElementById('networkStatus').style.display = 'block';
    }
    
    console.log('‚úÖ System initialized successfully');
});

function checkForResumableExam() {
    // This would check localStorage for any exams that can be resumed
    // Implementation depends on your specific requirements
}

// ===== SECURITY ENHANCEMENTS =====
document.addEventListener('keydown', function(e) {
    // Block F12, Ctrl+Shift+I, Ctrl+Shift+J, Ctrl+U
    if (e.key === 'F12' || 
        (e.ctrlKey && e.shiftKey && e.key === 'I') ||
        (e.ctrlKey && e.shiftKey && e.key === 'J') ||
        (e.ctrlKey && e.key === 'u')) {
        e.preventDefault();
        return false;
    }
});

// Disable right-click context menu
document.addEventListener('contextmenu', function(e) {
    if (examInProgress) {
        e.preventDefault();
        return false;
    }
});

// ===== CLEANUP ON EXIT =====
window.addEventListener('beforeunload', function(e) {
    if (examInProgress && !hasSubmitted) {
        e.preventDefault();
        e.returnValue = 'You have an exam in progress. Are you sure you want to leave?';
        return e.returnValue;
    }
});

// ===== CLEAN OLD BACKUPS =====
function cleanOldBackups() {
    const now = Date.now();
    const oneWeekAgo = now - (7 * 24 * 60 * 60 * 1000);
    let cleaned = 0;
    
    for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key && key.startsWith('exam_backup_')) {
            try {
                const backup = JSON.parse(localStorage.getItem(key));
                if (backup && backup.lastBackup) {
                    const backupTime = new Date(backup.lastBackup).getTime();
                    if (backupTime < oneWeekAgo) {
                        localStorage.removeItem(key);
                        cleaned++;
                    }
                }
            } catch (e) {
                // Remove corrupted backups
                localStorage.removeItem(key);
                cleaned++;
            }
        }
    }
    
    console.log(`üßπ Cleaned ${cleaned} old backups`);
    return cleaned;
}

// Initialize cleanup on load
setTimeout(cleanOldBackups, 1000);
</script>
</body>
</html>
