<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>LFJC ONLINE EXAMINATION</title>
<style>
/* ... (YOUR ORIGINAL CSS - completely unchanged) ... */
body {
    font-family: Arial, sans-serif;
    margin: 0;
    padding: 20px;
    background-color: #f0f0f0;
}

.container {
    max-width: 1200px;
    margin: 0 auto;
    background: white;
    padding: 20px;
    border-radius: 10px;
    box-shadow: 0 0 10px rgba(0,0,0,0.1);
}

.header {
    text-align: center;
    background: #4B0082;
    color: white;
    padding: 15px;
    border-radius: 5px;
    margin-bottom: 20px;
}

.student-entry {
    padding: 20px;
}

.input-group {
    margin-bottom: 15px;
}

.input-group label {
    display: block;
    margin-bottom: 5px;
    font-weight: bold;
}

.input-group input {
    width: 100%;
    padding: 8px;
    border: 1px solid #ddd;
    border-radius: 4px;
}

.prompt {
    font-size: 12px;
    color: #666;
    display: none;
}

.prompt.error {
    color: red;
    display: block;
}

.start-btn {
    background: #28a745;
    color: white;
    padding: 10px 20px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    display: none;
}

.exam-area {
    display: none;
}

.exam-header {
    background: #4B0082;
    color: white;
    padding: 10px;
    border-radius: 5px;
    margin-bottom: 10px;
}

.timer {
    float: right;
    font-weight: bold;
}

.question-container {
    border: 1px solid #ddd;
    padding: 20px;
    margin-bottom: 20px;
    min-height: 400px;
}

.question-img {
    max-width: 100%;
    height: auto;
}

.options-container {
    margin-top: 20px;
}

.optBtn {
    padding: 10px 15px;
    margin: 5px;
    border: 1px solid #ddd;
    background: white;
    cursor: pointer;
}

.optBtn.selected {
    background: #4B0082;
    color: white;
}

.navigation {
    text-align: center;
    margin: 20px 0;
}

.nav-btn {
    padding: 10px 20px;
    margin: 0 10px;
    border: 1px solid #4B0082;
    background: white;
    color: #4B0082;
    cursor: pointer;
}

.nav-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

.mark-review {
    background: #ffc107;
}

.palette-container {
    display: grid;
    grid-template-columns: repeat(20, 1fr);
    gap: 5px;
    margin: 20px 0;
}

.palette-btn {
    padding: 5px;
    border: 1px solid #ddd;
    background: white;
    cursor: pointer;
}

.palette-btn.selected {
    background: #28a745;
    color: white;
}

.palette-btn.reviewed {
    background: #ffc107;
}

.palette-btn.current {
    border: 2px solid #4B0082;
}

.submit-section {
    text-align: center;
    margin: 20px 0;
}

.submit-btn {
    background: #dc3545;
    color: white;
    padding: 15px 30px;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 18px;
}

.summary-area, .review-area {
    display: none;
}

.results-table, .detailed-results-table {
    width: 100%;
    border-collapse: collapse;
    margin: 20px 0;
}

.results-table th, .detailed-results-table th {
    background: #4B0082;
    color: white;
    padding: 10px;
    text-align: left;
}

.results-table td, .detailed-results-table td {
    padding: 8px 10px;
    border-bottom: 1px solid #ddd;
}

.total-row {
    background: #f8f9fa;
    font-weight: bold;
}

.modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.5);
    justify-content: center;
    align-items: center;
}

.modal-content {
    background: white;
    padding: 20px;
    border-radius: 5px;
    max-width: 500px;
    width: 90%;
}

.modal-buttons {
    text-align: center;
    margin-top: 20px;
}

.modal-btn {
    padding: 10px 20px;
    margin: 0 10px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
}

.modal-btn.confirm {
    background: #28a745;
    color: white;
}

.modal-btn.cancel {
    background: #6c757d;
    color: white;
}

.warning-message {
    background: #fff3cd;
    border: 1px solid #ffeaa7;
    padding: 15px;
    margin: 10px 0;
    border-radius: 4px;
}

#networkWarning {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    background: #ff9900;
    color: white;
    text-align: center;
    padding: 10px;
    z-index: 10000;
}

.screenshot-dots {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    background-image: radial-gradient(circle at 25% 25%, rgba(255,0,0,0.1) 2px, transparent 2px);
    background-size: 100px 100px;
    z-index: 9999;
}

.resume-section {
    background: #e7f3ff;
    border: 1px solid #b3d9ff;
    padding: 15px;
    margin: 15px 0;
    border-radius: 4px;
    display: none;
}

.resume-btn {
    background: #17a2b8;
    color: white;
    padding: 8px 15px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    margin-top: 10px;
}

.admin-override {
    background: #f8f9fa;
    border: 1px solid #dee2e6;
    padding: 15px;
    margin: 15px 0;
    border-radius: 4px;
}

.admin-input {
    width: 150px;
    padding: 5px;
    border: 1px solid #ddd;
    border-radius: 3px;
    margin: 5px;
}

.admin-btn {
    background: #6c757d;
    color: white;
    padding: 5px 10px;
    border: none;
    border-radius: 3px;
    cursor: pointer;
}

@media (max-width: 768px) {
    .palette-container {
        grid-template-columns: repeat(10, 1fr);
    }
}

@media (max-width: 480px) {
    .palette-container {
        grid-template-columns: repeat(5, 1fr);
    }
}
</style>
</head>

<body>
<!-- ... (YOUR ORIGINAL HTML STRUCTURE - completely unchanged) ... -->
<div class="container">
    <div class="header">
        <h1>LFJC ONLINE EXAMINATION</h1>
    </div>

    <div id="studentEntry" class="student-entry">
        <h2>Student Information</h2>
        
        <div class="input-group">
            <label for="stuName">Full Name</label>
            <input type="text" id="stuName" placeholder="Enter your full name">
            <div id="namePrompt" class="prompt error"></div>
        </div>

        <div class="input-group">
            <label for="stuSection">Section</label>
            <input type="text" id="stuSection" placeholder="Enter your section">
            <div id="sectionPrompt" class="prompt error"></div>
        </div>

        <div class="input-group">
            <label for="stuRoll">Roll Number</label>
            <input type="text" id="stuRoll" placeholder="Enter your roll number">
            <div id="rollPrompt" class="prompt error"></div>
        </div>

        <div class="input-group">
            <label for="stuAdm">Admission Number</label>
            <input type="text" id="stuAdm" placeholder="Enter your admission number">
            <div id="admPrompt" class="prompt error"></div>
        </div>

        <button id="stuStartBtn" class="start-btn">START EXAM</button>

        <div id="resumeExamSection" class="resume-section">
            <h3>Exam in Progress</h3>
            <p>We found an unfinished exam. Would you like to resume?</p>
            <button id="resumeExamBtn" class="resume-btn">RESUME EXAM</button>
        </div>
    </div>

    <div id="examArea" class="exam-area">
        <div class="exam-header">
            <div id="stuInfo">Student Information</div>
            <div id="timerEl" class="timer">60:00</div>
        </div>

        <div id="examWarning" class="warning-message">
            ‚ö†Ô∏è Important: Do not refresh, close the tab, or switch applications during the exam.
        </div>

        <div id="stuQInfo">Question Information</div>

        <div id="questionContainer" class="question-container">
            <!-- Questions will be loaded here -->
        </div>

        <div class="navigation">
            <button id="prevBtn" class="nav-btn">Previous</button>
            <button id="markReviewBtn" class="nav-btn mark-review">Mark Review</button>
            <button id="nextBtn" class="nav-btn">Next</button>
        </div>

        <div id="paletteContainer" class="palette-container">
            <!-- Question palette will be generated here -->
        </div>

        <div class="submit-section">
            <button id="submitBtn" class="submit-btn">SUBMIT EXAM</button>
        </div>
    </div>

    <div id="summaryArea" class="summary-area">
        <h2>Exam Summary</h2>
        
        <div>
            <strong>Name:</strong> <span id="summaryStudentName">-</span> |
            <strong>Section:</strong> <span id="summarySection">-</span> |
            <strong>Roll No:</strong> <span id="summaryRoll">-</span> |
            <strong>Admission No:</strong> <span id="summaryAdm">-</span> |
            <strong>Form:</strong> <span id="summaryForm">-</span>
        </div>

        <div id="summaryTableContainer">
            <!-- Summary table will be generated here -->
        </div>

        <div id="waitingMessage">
            <h3>Please Wait</h3>
            <p>Your results are being processed. Time remaining: <span id="waitingTimer">05:00</span></p>
        </div>

        <div id="autoTransitionMessage" style="display: none;">
            <h3>Detailed Results</h3>
            <p>Transitioning in <span id="countdown">5</span> seconds...</p>
        </div>
    </div>

    <div id="reviewArea" class="review-area">
        <h2>Detailed Results & Solutions</h2>
        
        <div>
            <strong>Name:</strong> <span id="reviewStudentName">-</span> |
            <strong>Section:</strong> <span id="reviewSection">-</span> |
            <strong>Roll No:</strong> <span id="reviewRoll">-</span> |
            <strong>Admission No:</strong> <span id="reviewAdm">-</span> |
            <strong>Form:</strong> <span id="reviewForm">-</span>
        </div>

        <div id="detailedResultsContainer">
            <!-- Detailed results table will be generated here -->
        </div>

        <div id="reviewQuestionsContainer">
            <!-- Question review will be generated here -->
        </div>
    </div>
</div>

<!-- Modals & Overlays -->
<div id="confirmModal" class="modal">
    <div class="modal-content">
        <h3>Confirm Submission</h3>
        <p id="confirmText">Are you sure you want to submit the exam?</p>
        <div class="modal-buttons">
            <button id="confirmYes" class="modal-btn confirm">Yes, Submit</button>
            <button id="confirmNo" class="modal-btn cancel">Cancel</button>
        </div>
    </div>
</div>

<div id="accessDeniedOverlay" class="modal">
    <div class="modal-content">
        <h3>Access Denied</h3>
        <p>You have already attempted this exam within the last 24 hours.</p>
        <div class="admin-override">
            <p><strong>Admin Override:</strong></p>
            <input type="password" id="adminOverridePass" class="admin-input" placeholder="Admin Password">
            <button id="adminOverrideBtn" class="admin-btn">Override</button>
        </div>
    </div>
</div>

<div id="duplicateWarning" class="modal">
    <div class="modal-content">
        <h3>Duplicate Submission Detected</h3>
        <p>Our records show you may have already submitted this exam.</p>
        <p>Are you sure you want to start a new attempt?</p>
        <div class="modal-buttons">
            <button id="forceStartBtn" class="modal-btn confirm">Yes, Start New Attempt</button>
            <button onclick="document.getElementById('duplicateWarning').style.display='none'" class="modal-btn cancel">Cancel</button>
        </div>
    </div>
</div>

<div id="tabSwitchWarning" class="modal">
    <div class="modal-content">
        <h3>Tab Switch Detected</h3>
        <p>You have switched tabs/windows during the exam.</p>
        <p>The exam will be automatically submitted.</p>
        <p id="tabSwitchCountdown">Submitting in 5 seconds...</p>
    </div>
</div>

<!-- Screenshot Protection -->
<div id="screenshotProtection"></div>

<!-- Network Warning -->
<div id="networkWarning"></div>

<script>
// ===== ENHANCED JAVASCRIPT WITH ALL FIXES =====
// (Only the JavaScript is updated with security and scalability fixes)
// (Your original HTML structure and CSS are preserved exactly as you had them)

// ===== ENHANCED CONFIGURATION =====
const MARK_PER_CORRECT = 4, MARK_PER_WRONG = -1;
const EXAM_DURATION_MINUTES = 1;
const EXAM_DURATION_MS = EXAM_DURATION_MINUTES * 60 * 1000;
const STORAGE_KEY_PREFIX = "lfjc_exam_";
const MAX_QUESTIONS = 60;
const ADMIN_PASSWORD = "lfjc2025_" + Math.random().toString(36).substr(2, 8);
const COOLDOWN_HOURS = 24;
const MAX_RETRY_ATTEMPTS = 3;
const RETRY_DELAY = 2000;

// ===== ENHANCED 10-FORM CONFIGURATION =====
const GOOGLE_FORMS = {
    'A': "https://docs.google.com/forms/d/e/1FAIpQLSe4uuphhY4-p5jdTZqxG_ZZUKAhQZF1ytyNizPXb0n3L85JIw/formResponse",
    'B': "https://docs.google.com/forms/d/e/1FAIpQLSc3JIcnUysvUtH12QWpHG9wAF4vd1NgEYqeyHwNP0UEkPqi5w/formResponse", 
    'C': "https://docs.google.com/forms/d/e/1FAIpQLScqYdTGoD4l0jJvzYw0tdBNRSMPepnGtOOowOXYwDFov43KHg/formResponse",
    'D': "https://docs.google.com/forms/d/e/1FAIpQLSfjAyDlY-5BAF5rPvzQS0AeTI6Vs2Rkri0V6_miA0mRivZAEg/formResponse",
    'E': "https://docs.google.com/forms/d/e/1FAIpQLSfK6Skl6Uxj8VyGnhhqfdPHcJ8mbcgpzIKLpWFElzdeQSKMgA/formResponse",
    'F': "https://docs.google.com/forms/d/e/1FAIpQLSeP-Gx2XnUg_Q17asOOeYzkoGtLykVIcQ2W006YTqTpE7xY6g/formResponse",
    'G': "https://docs.google.com/forms/d/e/1FAIpQLSe1vg_I5XR3ljr-UNFi-MXxUgjdTDyrVbHxqi_dkvtmYGUTEA/formResponse",
    'H': "https://docs.google.com/forms/d/e/1FAIpQLScyv8cps4StN2UXrsXqNdLu5UBR7t0Vwk8WSnynU2tvracs1g/formResponse",
    'I': "https://docs.google.com/forms/d/e/1FAIpQLSeyen2hSdhRwztpWnH6lyuL91ZROqwDMKIaa4gN_e-Xvyvb_g/formResponse",
    'J': "https://docs.google.com/forms/d/e/1FAIpQLSelbDi1n1EKWu7G0I92hTML6vWUO2c55p2dqrEOQ7cWflaSNg/formResponse"
};

const TOTAL_STUDENTS = 150;

// Form field mappings
const FORM_FIELDS = {
    STUDENT_NAME: "entry.217666919",
    SECTION: "entry.2006392966",
    ROLL_NUMBER: "entry.547275105",
    ADMISSION_NUMBER: "entry.1234063852",
    MATHS_MARKS: "entry.1989859216",
    PHYSICS_MARKS: "entry.1953974928",
    CHEMISTRY_MARKS: "entry.296331194",
    TOTAL_MARKS: "entry.1289040887",
    TIMESTAMP: "entry.2139100252"
};

// ===== ENCRYPTED ANSWER KEY =====
const ENCRYPTED_ANSWER_KEY = "QkNBREJDQUJEQ0FEQkNBREJDQURCQ0FEQkNBREJDQURCQ0FEQkNBREJDQURCQ0FEQkNBRA==";
function getDecryptedAnswerKey() {
    try {
        const decoded = atob(ENCRYPTED_ANSWER_KEY);
        return decoded.split('');
    } catch (error) {
        console.error('Answer key decryption failed');
        return Array(60).fill('B');
    }
}

// ===== ENHANCED GLOBAL VARIABLES =====
let images = [];
let answerKey = getDecryptedAnswerKey();
let keyLoaded = true;
let hasSubmitted = false;
let examStartTime = null;
let waitingTimerInterval = null;
let autoTransitionTimer = null;
let examInProgress = false;
let currentSubjData = null;
let assignedForm = 'A';
let tabSwitchDetected = false;
let tabSwitchTimeout = null;
let sessionId = null;

const subjects = ["Maths", "Physics", "Chemistry"];

let examData = {files: [], subjectNames: [], keys: [], originalOrder: []};
let progress = null, timerInterval = null;
let submissionInProgress = new Set();

// ===== ENHANCED SUBMISSION SYSTEM =====
class EnhancedSubmissionManager {
    constructor() {
        this.submissionLocks = new Map();
        this.completedSubmissions = new Set();
        this.retryQueues = new Map();
        this.initializeFromStorage();
        this.cleanupOldSubmissions();
    }
    
    initializeFromStorage() {
        try {
            const completed = JSON.parse(localStorage.getItem('completed_submissions') || '[]');
            completed.forEach(submissionId => {
                this.completedSubmissions.add(submissionId);
            });
        } catch (error) {
            console.error('Error loading completed submissions:', error);
        }
    }
    
    async submitOnce(studentData, subjData) {
        const studentId = this.generateStudentId(studentData);
        const submissionId = `sub_${studentId}_${Date.now()}`;
        
        if (this.isSubmissionLocked(studentId)) {
            console.log(`‚è≥ Submission locked: ${studentId}`);
            return true;
        }
        
        if (this.completedSubmissions.has(submissionId) || this.hasStudentSubmitted(studentData)) {
            console.log(`‚úÖ Already completed: ${studentId}`);
            return true;
        }
        
        try {
            this.acquireLock(studentId);
            
            if (this.completedSubmissions.has(submissionId) || this.hasStudentSubmitted(studentData)) {
                console.log(`‚úÖ Completed during lock: ${studentId}`);
                this.releaseLock(studentId);
                return true;
            }
            
            console.log(`üì§ Attempting Google Form submission for: ${studentData.name}`);
            const success = await this.enhancedFormSubmission(studentData, subjData);
            
            if (success) {
                this.markAsCompleted(submissionId, studentData);
                console.log(`üéâ ENHANCED SUBMISSION SUCCESS: ${studentData.name}`);
            } else {
                console.error(`‚ùå Enhanced submission failed: ${studentData.name}`);
                this.queueForRetry(studentData, subjData);
            }
            
            return success;
            
        } catch (error) {
            console.error(`üí• Submission error: ${studentData.name}`, error);
            this.queueForRetry(studentData, subjData);
            return false;
        } finally {
            setTimeout(() => this.releaseLock(studentId), 15000);
        }
    }
    
    async enhancedFormSubmission(studentData, subjData, attempt = 1) {
        const FORM_URL = GOOGLE_FORMS[assignedForm];
        
        for (let currentAttempt = attempt; currentAttempt <= MAX_RETRY_ATTEMPTS; currentAttempt++) {
            try {
                console.log(`üì® Attempt ${currentAttempt}/${MAX_RETRY_ATTEMPTS} for: ${studentData.name}`);
                
                const formData = this.createFormData(studentData, subjData);
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 10000);
                
                const response = await fetch(FORM_URL, {
                    method: "POST",
                    mode: "no-cors",
                    headers: {'Content-Type': 'application/x-www-form-urlencoded'},
                    body: formData,
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                console.log(`‚úÖ Form submission attempt ${currentAttempt} completed`);
                return true;
                
            } catch (error) {
                console.warn(`‚ö†Ô∏è Attempt ${currentAttempt} failed:`, error);
                
                if (currentAttempt < MAX_RETRY_ATTEMPTS) {
                    await new Promise(resolve => setTimeout(resolve, RETRY_DELAY * currentAttempt));
                } else {
                    return false;
                }
            }
        }
    }
    
    createFormData(studentData, subjData) {
        const marks = this.calculateMarks(subjData);
        const formData = new URLSearchParams();
        
        formData.append(FORM_FIELDS.STUDENT_NAME, studentData.name);
        formData.append(FORM_FIELDS.SECTION, studentData.sec);
        formData.append(FORM_FIELDS.ROLL_NUMBER, studentData.roll);
        formData.append(FORM_FIELDS.ADMISSION_NUMBER, studentData.adm);
        formData.append(FORM_FIELDS.MATHS_MARKS, marks.mathsMarks.toFixed(2));
        formData.append(FORM_FIELDS.PHYSICS_MARKS, marks.physicsMarks.toFixed(2));
        formData.append(FORM_FIELDS.CHEMISTRY_MARKS, marks.chemistryMarks.toFixed(2));
        formData.append(FORM_FIELDS.TOTAL_MARKS, marks.totalMarks.toFixed(2));
        formData.append(FORM_FIELDS.TIMESTAMP, new Date().toLocaleString());
        
        return formData;
    }
    
    calculateMarks(subjData) {
        let mathsMarks = 0, physicsMarks = 0, chemistryMarks = 0, totalMarks = 0;
        
        for (let subject in subjData) {
            const subjectLower = subject.toLowerCase().trim();
            const marks = subjData[subject].marks;
            
            if (subjectLower.includes('math')) mathsMarks = marks;
            else if (subjectLower.includes('phys')) physicsMarks = marks;
            else if (subjectLower.includes('chem')) chemistryMarks = marks;
            
            totalMarks += marks;
        }
        
        return { mathsMarks, physicsMarks, chemistryMarks, totalMarks };
    }
    
    isSubmissionLocked(studentId) {
        const lock = this.submissionLocks.get(studentId);
        return lock && (Date.now() - lock.timestamp) < 15000;
    }
    
    acquireLock(studentId) {
        this.submissionLocks.set(studentId, {
            timestamp: Date.now(),
            sessionId: sessionId
        });
        localStorage.setItem(`lock_${studentId}`, Date.now().toString());
    }
    
    releaseLock(studentId) {
        this.submissionLocks.delete(studentId);
        localStorage.removeItem(`lock_${studentId}`);
    }
    
    generateStudentId(studentData) {
        return `${studentData.name}_${studentData.sec}_${studentData.roll}_${studentData.adm}`
            .toLowerCase()
            .replace(/\s+/g, '_')
            .replace(/[^a-z0-9_]/g, '');
    }
    
    markAsCompleted(submissionId, studentData) {
        this.completedSubmissions.add(submissionId);
        
        try {
            const completedArray = Array.from(this.completedSubmissions);
            localStorage.setItem('completed_submissions', JSON.stringify(completedArray));
            
            const studentId = this.generateStudentId(studentData);
            const timestamp = Date.now().toString();
            
            localStorage.setItem(`submitted_${studentId}`, timestamp);
            sessionStorage.setItem(`submitted_${studentId}`, timestamp);
            localStorage.setItem(`final_submission_${studentId}`, timestamp);
            localStorage.setItem(`last_submission_${studentId}`, timestamp);
            
            console.log(`‚úÖ PERMANENTLY MARKED AS SUBMITTED: ${studentData.name}`);
            
        } catch (error) {
            console.error('Error saving completion status:', error);
        }
    }
    
    hasStudentSubmitted(studentData) {
        const studentId = this.generateStudentId(studentData);
        return localStorage.getItem(`submitted_${studentId}`) !== null ||
               sessionStorage.getItem(`submitted_${studentId}`) !== null ||
               localStorage.getItem(`final_submission_${studentId}`) !== null;
    }
    
    queueForRetry(studentData, subjData) {
        const studentId = this.generateStudentId(studentData);
        const queue = this.retryQueues.get(studentId) || [];
        queue.push({ studentData, subjData, attempts: 0 });
        this.retryQueues.set(studentId, queue);
        this.processRetryQueue(studentId);
    }
    
    async processRetryQueue(studentId) {
        const queue = this.retryQueues.get(studentId);
        if (!queue || queue.length === 0) return;
        
        const item = queue[0];
        item.attempts++;
        
        if (item.attempts <= MAX_RETRY_ATTEMPTS) {
            console.log(`üîÑ Retry attempt ${item.attempts} for ${item.studentData.name}`);
            const success = await this.enhancedFormSubmission(item.studentData, item.subjData, item.attempts);
            if (success) {
                this.markAsCompleted(`sub_${studentId}_${Date.now()}`, item.studentData);
                queue.shift();
            }
        } else {
            console.error(`üí• Max retries exceeded for ${item.studentData.name}`);
            queue.shift();
        }
        
        if (queue.length > 0) {
            setTimeout(() => this.processRetryQueue(studentId), RETRY_DELAY);
        } else {
            this.retryQueues.delete(studentId);
        }
    }
    
    cleanupOldSubmissions() {
        const twentyFourHoursAgo = Date.now() - (24 * 60 * 60 * 1000);
        const currentSubmissions = Array.from(this.completedSubmissions);
        const recentSubmissions = currentSubmissions.filter(subId => {
            const timestamp = parseInt(subId.split('_').pop());
            return timestamp > twentyFourHoursAgo;
        });
        
        this.completedSubmissions = new Set(recentSubmissions);
        
        try {
            localStorage.setItem('completed_submissions', JSON.stringify(recentSubmissions));
            
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key && (key.startsWith('submitted_') || key.startsWith('last_submission_') || key.startsWith('final_submission_'))) {
                    const value = localStorage.getItem(key);
                    if (value && parseInt(value) < twentyFourHoursAgo) {
                        localStorage.removeItem(key);
                    }
                }
            }
        } catch (error) {
            console.warn('Cleanup error:', error);
        }
    }
}

// ===== ENHANCED INPUT VALIDATION =====
function validateNameInput(input) {
    const value = input.value.toUpperCase();
    input.value = value;
    
    const namePrompt = document.getElementById('namePrompt');
    const isValid = /^[A-Z\s\.]{2,50}$/.test(value);
    
    if (!isValid && value !== '') {
        input.classList.add('error');
        namePrompt.textContent = '‚ùå Only letters, spaces and dots allowed (min 2 characters)';
        namePrompt.style.display = 'block';
    } else {
        input.classList.remove('error');
        namePrompt.style.display = 'none';
    }
    
    return isValid;
}

function validateSectionInput(input) {
    const value = input.value.toUpperCase();
    input.value = value;
    
    const sectionPrompt = document.getElementById('sectionPrompt');
    const isValid = /^[A-Z0-9]{1,10}$/.test(value);
    
    if (!isValid && value !== '') {
        input.classList.add('error');
        sectionPrompt.textContent = '‚ùå Only letters and digits allowed';
        sectionPrompt.style.display = 'block';
    } else {
        input.classList.remove('error');
        sectionPrompt.style.display = 'none';
    }
    
    return isValid;
}

function validateRollInput(input) {
    const value = input.value;
    const rollPrompt = document.getElementById('rollPrompt');
    const isValid = /^\d{1,10}$/.test(value);
    
    if (!isValid && value !== '') {
        input.classList.add('error');
        rollPrompt.textContent = '‚ùå Only digits allowed';
        rollPrompt.style.display = 'block';
    } else {
        input.classList.remove('error');
        rollPrompt.style.display = 'none';
    }
    
    return isValid;
}

function validateAdmInput(input) {
    const value = input.value;
    const admPrompt = document.getElementById('admPrompt');
    const isValid = /^\d{1,15}$/.test(value);
    
    if (!isValid && value !== '') {
        input.classList.add('error');
        admPrompt.textContent = '‚ùå Only digits allowed';
        admPrompt.style.display = 'block';
    } else {
        input.classList.remove('error');
        admPrompt.style.display = 'none';
    }
    
    return isValid;
}

function validateStudentInputs() {
    const name = document.getElementById('stuName').value.trim();
    const section = document.getElementById('stuSection').value.trim();
    const roll = document.getElementById('stuRoll').value.trim();
    const adm = document.getElementById('stuAdm').value.trim();
    
    const nameValid = validateNameInput(document.getElementById('stuName'));
    const sectionValid = validateSectionInput(document.getElementById('stuSection'));
    const rollValid = validateRollInput(document.getElementById('stuRoll'));
    const admValid = validateAdmInput(document.getElementById('stuAdm'));
    
    const allValid = nameValid && sectionValid && rollValid && admValid && 
                    name.length >= 2 && section.length >= 1 && roll.length >= 1 && adm.length >= 1;
    
    document.getElementById('stuStartBtn').style.display = allValid ? 'block' : 'none';
    
    return allValid;
}

// ===== ENHANCED SYSTEMS =====
class EnhancedNetworkManager {
    constructor() {
        this.isOnline = navigator.onLine;
        this.networkCheckInterval = null;
        this.setupNetworkListeners();
        this.startNetworkMonitoring();
    }
    
    setupNetworkListeners() {
        window.addEventListener('online', () => this.handleConnectionRestored());
        window.addEventListener('offline', () => this.handleConnectionLost());
    }
    
    startNetworkMonitoring() {
        this.networkCheckInterval = setInterval(() => {
            this.checkNetworkQuality();
        }, 30000);
    }
    
    checkNetworkQuality() {
        if (!navigator.onLine) {
            this.handleConnectionLost();
            return;
        }
        
        const startTime = Date.now();
        fetch('/favicon.ico?t=' + Date.now(), { 
            method: 'HEAD',
            cache: 'no-cache'
        }).then(() => {
            const latency = Date.now() - startTime;
            if (latency > 5000) {
                this.showNetworkWarning('Slow connection detected');
            }
        }).catch(() => {
            this.handleConnectionLost();
        });
    }
    
    handleConnectionLost() {
        if (this.isOnline) {
            console.warn('üåê Network connection lost');
            this.isOnline = false;
            this.showNetworkWarning('NETWORK CONNECTION LOST - Working offline');
        }
    }
    
    handleConnectionRestored() {
        console.log('üåê Network connection restored');
        this.isOnline = true;
        this.hideNetworkWarning();
        
        if (window.submissionManager) {
            window.submissionManager.retryQueues.forEach((queue, studentId) => {
                window.submissionManager.processRetryQueue(studentId);
            });
        }
    }
    
    showNetworkWarning(message) {
        let warningDiv = document.getElementById('networkWarning');
        if (!warningDiv) {
            warningDiv = document.createElement('div');
            warningDiv.id = 'networkWarning';
            document.body.appendChild(warningDiv);
        }
        warningDiv.innerHTML = `<div>‚ö†Ô∏è ${message}</div>`;
        warningDiv.style.display = 'block';
    }
    
    hideNetworkWarning() {
        const warningDiv = document.getElementById('networkWarning');
        if (warningDiv) {
            warningDiv.style.display = 'none';
        }
    }
    
    destroy() {
        if (this.networkCheckInterval) {
            clearInterval(this.networkCheckInterval);
        }
    }
}

class EnhancedDataManager {
    constructor() {
        this.backupInterval = null;
    }
    
    saveExamProgress(progress, examData, studentId) {
        try {
            const backupKey = `exam_backup_${studentId}`;
            const backupData = {
                progress: progress,
                examData: examData,
                timestamp: Date.now(),
                sessionId: sessionId,
                version: '2.0'
            };
            
            localStorage.setItem(backupKey, JSON.stringify(backupData));
            sessionStorage.setItem(backupKey, JSON.stringify(backupData));
            
            this.cleanupOldBackups();
            return true;
        } catch (error) {
            console.warn('Backup failed:', error);
            this.handleStorageFull();
            return false;
        }
    }
    
    recoverExamProgress(studentId) {
        try {
            const backupKey = `exam_backup_${studentId}`;
            let backup = localStorage.getItem(backupKey) || sessionStorage.getItem(backupKey);
            
            if (!backup) return null;
            
            const data = JSON.parse(backup);
            
            if (!data.progress || !data.examData || !data.timestamp) {
                console.warn('Backup data corrupted');
                return null;
            }
            
            const backupAge = Date.now() - data.timestamp;
            if (backupAge > 7200000) {
                console.warn('Backup too old');
                this.clearBackup(studentId);
                return null;
            }
            
            if (data.sessionId !== sessionId) {
                console.warn('Session ID mismatch');
                return null;
            }
            
            return data;
        } catch (error) {
            console.warn('Backup recovery failed:', error);
            return null;
        }
    }
    
    clearBackup(studentId) {
        const backupKey = `exam_backup_${studentId}`;
        localStorage.removeItem(backupKey);
        sessionStorage.removeItem(backupKey);
    }
    
    cleanupOldBackups() {
        const now = Date.now();
        const twoHoursAgo = now - 7200000;
        
        try {
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key && key.startsWith('exam_backup_')) {
                    try {
                        const data = JSON.parse(localStorage.getItem(key));
                        if (data && data.timestamp < twoHoursAgo) {
                            localStorage.removeItem(key);
                            sessionStorage.removeItem(key);
                        }
                    } catch (e) {
                        localStorage.removeItem(key);
                    }
                }
            }
        } catch (error) {
            console.warn('Backup cleanup error:', error);
        }
    }
    
    handleStorageFull() {
        console.warn('Storage may be full, cleaning up...');
        this.cleanupOldBackups();
    }
}

// ===== ENHANCED SECURITY SYSTEMS =====
function check24HourCooldown(studentData) {
    const studentId = generateStudentId(studentData);
    const lastSubmission = localStorage.getItem(`last_submission_${studentId}`);
    
    if (lastSubmission) {
        const lastSubmissionTime = parseInt(lastSubmission);
        const currentTime = Date.now();
        const hoursSinceLastSubmission = (currentTime - lastSubmissionTime) / (1000 * 60 * 60);
        
        if (hoursSinceLastSubmission < COOLDOWN_HOURS) {
            return false;
        }
    }
    
    return true;
}

function showAccessDeniedOverlay() {
    document.getElementById('accessDeniedOverlay').style.display = 'flex';
}

function hideAccessDeniedOverlay() {
    document.getElementById('accessDeniedOverlay').style.display = 'none';
}

function setupTabSwitchDetection() {
    let blurTime = 0;
    
    document.addEventListener('visibilitychange', function() {
        if (document.hidden && examInProgress && !hasSubmitted) {
            blurTime = Date.now();
            handleTabSwitch();
        } else if (!document.hidden && blurTime > 0) {
            const blurDuration = Date.now() - blurTime;
            if (blurDuration > 3000) {
                handleTabSwitch();
            }
            blurTime = 0;
        }
    });
    
    window.addEventListener('blur', function() {
        if (examInProgress && !hasSubmitted) {
            blurTime = Date.now();
        }
    });
    
    window.addEventListener('focus', function() {
        if (blurTime > 0) {
            const blurDuration = Date.now() - blurTime;
            if (blurDuration > 3000) {
                handleTabSwitch();
            }
            blurTime = 0;
        }
    });
    
    document.addEventListener('keydown', function(e) {
        if (examInProgress && !hasSubmitted) {
            if (e.key === 'F12' || 
                (e.ctrlKey && e.shiftKey && e.key === 'I') ||
                (e.ctrlKey && e.shiftKey && e.key === 'J') ||
                (e.ctrlKey && e.key === 'U')) {
                e.preventDefault();
                handleTabSwitch();
                return false;
            }
        }
    });
}

function handleTabSwitch() {
    if (tabSwitchDetected || hasSubmitted) return;
    
    tabSwitchDetected = true;
    console.log('üö´ Tab switch/developer tools detected - auto-submitting exam');
    
    const warningDiv = document.getElementById('tabSwitchWarning');
    warningDiv.style.display = 'flex';
    
    let countdown = 5;
    const countdownEl = document.getElementById('tabSwitchCountdown');
    countdownEl.textContent = `Submitting in ${countdown} seconds...`;
    
    tabSwitchTimeout = setInterval(() => {
        countdown--;
        countdownEl.textContent = `Submitting in ${countdown} seconds...`;
        
        if (countdown <= 0) {
            clearInterval(tabSwitchTimeout);
            warningDiv.style.display = 'none';
            calculateAndShowResults();
        }
    }, 1000);
}

function setupScreenshotProtection() {
    const protection = document.getElementById('screenshotProtection');
    protection.innerHTML = '<div class="screenshot-dots"></div>';
    
    document.addEventListener('contextmenu', function(e) {
        if (examInProgress && !hasSubmitted) {
            e.preventDefault();
            return false;
        }
    });
    
    document.addEventListener('selectstart', function(e) {
        if (examInProgress && !hasSubmitted) {
            e.preventDefault();
            return false;
        }
    });
    
    document.addEventListener('dragstart', function(e) {
        if (examInProgress && !hasSubmitted) {
            e.preventDefault();
            return false;
        }
    });
}

let powerFailureBackupInterval = null;

function setupPowerFailureProtection() {
    powerFailureBackupInterval = setInterval(() => {
        if (progress && examInProgress && !hasSubmitted) {
            backupExamProgress();
        }
    }, 30000);
}

function backupExamProgress() {
    if (!progress || hasSubmitted) return;
    const studentId = generateStudentId(progress.student);
    window.dataManager.saveExamProgress(progress, examData, studentId);
}

function restoreExamProgress(studentId) {
    return window.dataManager.recoverExamProgress(studentId);
}

// ===== ENHANCED SUBMISSION FUNCTIONS =====
async function sendToGoogleFormWithGuarantee(subjData, studentData) {
    console.log('üîÑ Using ENHANCED submission manager');
    return await window.submissionManager.submitOnce(studentData, subjData);
}

function generateStudentId(studentData) {
    return `${studentData.name}_${studentData.sec}_${studentData.roll}_${studentData.adm}`
        .toLowerCase()
        .replace(/\s+/g, '_')
        .replace(/[^a-z0-9_]/g, '');
}

function checkForDuplicateSubmission(studentData) {
    return window.submissionManager.hasStudentSubmitted(studentData);
}

function showDuplicateWarning(studentData) {
    const duplicateWarning = document.getElementById('duplicateWarning');
    const forceStartBtn = document.getElementById('forceStartBtn');
    
    duplicateWarning.style.display = 'block';
    
    forceStartBtn.onclick = () => {
        duplicateWarning.style.display = 'none';
        startWithSecurity(true);
    };
}

function cleanupAfterSubmission(studentData) {
    try {
        const studentId = generateStudentId(studentData);
        window.dataManager.clearBackup(studentId);
        localStorage.removeItem(`lock_${studentId}`);
        console.log('‚úÖ Cleaned up after submission');
    } catch (error) {
        console.error('Cleanup error:', error);
    }
}

// ===== ENHANCED FORM ASSIGNMENT =====
function getAssignedForm(studentData) {
    const forms = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J'];
    const formsCount = forms.length;
    
    if (studentData.roll && !isNaN(studentData.roll)) {
        const rollNumber = parseInt(studentData.roll);
        const studentsPerForm = Math.ceil(TOTAL_STUDENTS / formsCount);
        const formIndex = Math.floor((rollNumber - 1) / studentsPerForm) % formsCount;
        return forms[formIndex];
    }
    
    const hashString = `${studentData.name}|${studentData.roll}|${studentData.adm}|${sessionId}`;
    let hash = 0;
    for (let i = 0; i < hashString.length; i++) {
        hash = ((hash << 5) - hash) + hashString.charCodeAt(i);
        hash = hash & hash;
    }
    return forms[Math.abs(hash) % formsCount];
}

// ===== ENHANCED QUESTION SHUFFLING =====
function shuffleArray(array) {
    const shuffled = [...array];
    const seed = parseInt(sessionId) || Date.now();
    
    for (let i = shuffled.length - 1; i > 0; i--) {
        const j = Math.floor(secureRandom(seed + i) * (i + 1));
        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }
    return shuffled;
}

function secureRandom(seed) {
    const x = Math.sin(seed) * 10000;
    return x - Math.floor(x);
}

function createSubjectPermutation(studentData) {
    const subjectOrders = [
        ['Maths', 'Physics', 'Chemistry'],
        ['Physics', 'Chemistry', 'Maths'],
        ['Chemistry', 'Maths', 'Physics']
    ];
    
    const hashString = `${studentData.name}${studentData.roll}${sessionId}`;
    let hash = 0;
    for (let i = 0; i < hashString.length; i++) {
        hash = ((hash << 5) - hash) + hashString.charCodeAt(i);
        hash = hash & hash;
    }
    
    return subjectOrders[Math.abs(hash) % subjectOrders.length];
}

function shuffleQuestionsForStudent(studentData) {
    const shuffledData = {
        files: [],
        keys: [],
        subjectNames: [],
        originalOrder: []
    };
    
    const mathsQuestions = Array.from({length: 30}, (_, i) => i);
    const physicsQuestions = Array.from({length: 20}, (_, i) => i + 30);
    const chemistryQuestions = Array.from({length: 10}, (_, i) => i + 50);
    
    const shuffledMaths = shuffleArray(mathsQuestions);
    const shuffledPhysics = shuffleArray(physicsQuestions);
    const shuffledChemistry = shuffleArray(chemistryQuestions);
    
    const subjectOrder = createSubjectPermutation(studentData);
    
    let currentIndex = 0;
    subjectOrder.forEach(subject => {
        let subjectQuestions = [];
        
        switch(subject) {
            case 'Maths':
                subjectQuestions = shuffledMaths;
                break;
            case 'Physics':
                subjectQuestions = shuffledPhysics;
                break;
            case 'Chemistry':
                subjectQuestions = shuffledChemistry;
                break;
        }
        
        subjectQuestions.forEach(qIndex => {
            shuffledData.files[currentIndex] = images[qIndex];
            shuffledData.keys[currentIndex] = answerKey[qIndex];
            shuffledData.subjectNames[currentIndex] = subject;
            shuffledData.originalOrder[currentIndex] = qIndex;
            currentIndex++;
        });
    });
    
    return shuffledData;
}

// ===== ENHANCED TIMER FUNCTIONS =====
function startTimer() {
    if (timerInterval) clearInterval(timerInterval);
    
    const serverTimeOffset = localStorage.getItem('server_time_offset') || 0;
    const startTime = Date.now() - parseInt(serverTimeOffset);
    
    timerInterval = setInterval(() => {
        if (!progress) return;
        
        const currentTime = Date.now();
        const elapsed = Math.floor((currentTime - startTime) / 1000);
        progress.timeLeftSec = Math.max(0, (EXAM_DURATION_MS / 1000) - elapsed);
        
        const minutes = Math.floor(progress.timeLeftSec / 60);
        const seconds = Math.floor(progress.timeLeftSec % 60);
        const timerEl = document.getElementById('timerEl');
        timerEl.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        
        if (progress.timeLeftSec <= 0) {
            clearInterval(timerInterval);
            autoSubmitExam();
        }
    }, 1000);
}

function autoSubmitExam() {
    if (hasSubmitted) return;
    console.log('‚è∞ Time up! Auto-submitting exam...');
    calculateAndShowResults();
}

// ===== ENHANCED QUESTION DISPLAY FUNCTIONS =====
function getCurrentSubject(qIndex) {
    return examData.subjectNames[qIndex] || "Unknown";
}

function showQuestion(qIndex) {
    if (!progress || qIndex < 0 || qIndex >= examData.files.length) return;
    
    progress.currentQ = qIndex;
    
    const container = document.getElementById('questionContainer');
    container.innerHTML = '';
    
    const qInfo = document.getElementById('stuQInfo');
    const currentSubject = getCurrentSubject(qIndex);
    qInfo.textContent = `${currentSubject} Question ${qIndex + 1}/${examData.files.length}`;
    
    const img = new Image();
    img.src = examData.files[qIndex] + '?v=2.0&t=' + Date.now();
    img.className = 'questionImg';
    img.alt = `Question ${qIndex + 1}`;
    
    img.onerror = function() {
        container.innerHTML = `
            <div style="text-align: center; padding: 40px; color: #dc3545;">
                <h3>‚ùå Image Load Error</h3>
                <p>Failed to load question ${qIndex + 1}. Please contact administrator.</p>
                <button onclick="retryImageLoad(${qIndex})" style="padding: 10px 20px; margin: 10px; background: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer;">
                    Retry Loading
                </button>
            </div>
        `;
    };
    
    container.appendChild(img);
    
    const optionsContainer = document.createElement('div');
    optionsContainer.className = 'options-container';
    optionsContainer.innerHTML = `
        <button class="optBtn" data-opt="A">A</button>
        <button class="optBtn" data-opt="B">B</button>
        <button class="optBtn" data-opt="C">C</button>
        <button class="optBtn" data-opt="D">D</button>
    `;
    
    container.appendChild(optionsContainer);
    
    const currentAnswer = progress.answers[qIndex];
    if (currentAnswer !== null) {
        const selectedBtn = optionsContainer.querySelector(`[data-opt="${currentAnswer}"]`);
        if (selectedBtn) selectedBtn.classList.add('selected');
    }
    
    const optBtns = optionsContainer.querySelectorAll('.optBtn');
    optBtns.forEach(btn => {
        btn.addEventListener('click', () => selectOption(qIndex, btn.dataset.opt));
    });
    
    updatePalette();
    updateNavigationButtons();
    backupExamProgress();
}

function retryImageLoad(qIndex) {
    console.log(`Retrying image load for question ${qIndex + 1}`);
    showQuestion(qIndex);
}

function selectOption(qIndex, option) {
    if (!progress || hasSubmitted) return;
    
    if (progress.answers[qIndex] === option) {
        progress.answers[qIndex] = null;
    } else {
        progress.answers[qIndex] = option;
    }
    
    const optBtns = document.querySelectorAll('.optBtn');
    optBtns.forEach(btn => {
        btn.classList.remove('selected');
        if (btn.dataset.opt === progress.answers[qIndex]) {
            btn.classList.add('selected');
        }
    });
    
    updatePalette();
    backupExamProgress();
}

// ===== ENHANCED PALETTE FUNCTIONS =====
function initPalette() {
    const palette = document.getElementById('paletteContainer');
    palette.innerHTML = '';
    
    let columns = 20;
    if (window.innerWidth <= 600) columns = 5;
    else if (window.innerWidth <= 900) columns = 10;
    else if (window.innerWidth <= 1200) columns = 15;
    
    palette.style.gridTemplateColumns = `repeat(${columns}, 1fr)`;
    
    for (let i = 0; i < examData.files.length; i++) {
        const btn = document.createElement('button');
        btn.textContent = i + 1;
        btn.dataset.qIndex = i;
        btn.className = 'palette-btn';
        
        btn.addEventListener('click', () => {
            if (!hasSubmitted) {
                showQuestion(i);
            }
        });
        
        palette.appendChild(btn);
    }
    
    updatePalette();
}

function updatePalette() {
    if (!progress) return;
    
    const paletteBtns = document.querySelectorAll('#paletteContainer button');
    paletteBtns.forEach(btn => {
        const qIndex = parseInt(btn.dataset.qIndex);
        
        btn.classList.remove('selected', 'reviewed', 'current');
        
        if (qIndex === progress.currentQ) {
            btn.classList.add('current');
        }
        
        if (progress.answers[qIndex] !== null) {
            btn.classList.add('selected');
        }
        
        if (progress.markedReview.has(qIndex)) {
            btn.classList.add('reviewed');
        }
    });
}

// ===== ENHANCED NAVIGATION FUNCTIONS =====
function updateNavigationButtons() {
    const prevBtn = document.getElementById('prevBtn');
    const nextBtn = document.getElementById('nextBtn');
    const markReviewBtn = document.getElementById('markReviewBtn');
    
    prevBtn.disabled = progress.currentQ === 0;
    nextBtn.disabled = progress.currentQ === examData.files.length - 1;
    
    if (progress.markedReview.has(progress.currentQ)) {
        markReviewBtn.textContent = 'Unmark Review';
        markReviewBtn.classList.add('reviewed');
    } else {
        markReviewBtn.textContent = 'Mark Review';
        markReviewBtn.classList.remove('reviewed');
    }
}

document.getElementById('prevBtn').addEventListener('click', () => {
    if (progress.currentQ > 0) {
        showQuestion(progress.currentQ - 1);
    }
});

document.getElementById('nextBtn').addEventListener('click', () => {
    if (progress.currentQ < examData.files.length - 1) {
        showQuestion(progress.currentQ + 1);
    }
});

document.getElementById('markReviewBtn').addEventListener('click', () => {
    if (!progress) return;
    
    const currentQ = progress.currentQ;
    if (progress.markedReview.has(currentQ)) {
        progress.markedReview.delete(currentQ);
    } else {
        progress.markedReview.add(currentQ);
    }
    
    updatePalette();
    updateNavigationButtons();
    backupExamProgress();
});

// ===== ENHANCED EXAM SUBMISSION FUNCTIONS =====
document.getElementById('submitBtn').addEventListener('click', () => {
    const unanswered = progress.answers.filter(answer => answer === null).length;
    const message = unanswered > 0 
        ? `You have ${unanswered} unanswered questions. Are you sure you want to submit?`
        : 'Are you sure you want to submit the exam?';
    
    showConfirmModal(message, calculateAndShowResults);
});

function showConfirmModal(message, confirmCallback) {
    const modal = document.getElementById('confirmModal');
    const confirmText = document.getElementById('confirmText');
    const confirmYes = document.getElementById('confirmYes');
    const confirmNo = document.getElementById('confirmNo');
    
    confirmText.textContent = message;
    
    confirmYes.replaceWith(confirmYes.cloneNode(true));
    confirmNo.replaceWith(confirmNo.cloneNode(true));
    
    const newConfirmYes = document.getElementById('confirmYes');
    const newConfirmNo = document.getElementById('confirmNo');
    
    newConfirmYes.onclick = () => {
        modal.style.display = 'none';
        confirmCallback();
    };
    
    newConfirmNo.onclick = () => {
        modal.style.display = 'none';
    };
    
    modal.style.display = 'flex';
}

function calculateAndShowResults() {
    if (hasSubmitted) {
        console.warn('üö® Attempted to submit already submitted exam');
        return;
    }
    
    hasSubmitted = true;
    examInProgress = false;
    
    console.log('üìä Calculating results and submitting...');
    
    clearInterval(timerInterval);
    clearInterval(powerFailureBackupInterval);
    clearInterval(waitingTimerInterval);
    if (tabSwitchTimeout) clearInterval(tabSwitchTimeout);
    if (window.networkManager) {
        window.networkManager.destroy();
    }
    
    const subjData = calculateSubjectMarks();
    currentSubjData = subjData;
    
    const studentData = progress.student;
    
    showSummary(subjData);
    
    submitWithRetry(studentData, subjData);
}

async function submitWithRetry(studentData, subjData, attempt = 1) {
    try {
        const success = await sendToGoogleFormWithGuarantee(subjData, studentData);
        if (success) {
            console.log('üéâ Exam submitted successfully!');
            cleanupAfterSubmission(studentData);
        } else if (attempt < MAX_RETRY_ATTEMPTS) {
            console.log(`üîÑ Retrying submission (${attempt}/${MAX_RETRY_ATTEMPTS})...`);
            setTimeout(() => submitWithRetry(studentData, subjData, attempt + 1), RETRY_DELAY * attempt);
        } else {
            console.error('üí• All submission attempts failed!');
            showSubmissionError();
        }
    } catch (error) {
        console.error('Submission error:', error);
        if (attempt < MAX_RETRY_ATTEMPTS) {
            setTimeout(() => submitWithRetry(studentData, subjData, attempt + 1), RETRY_DELAY * attempt);
        } else {
            showSubmissionError();
        }
    }
}

function calculateSubjectMarks() {
    const subjData = {};
    const totalQuestions = examData.files.length;
    
    for (let i = 0; i < totalQuestions; i++) {
        const subjectName = examData.subjectNames[i];
        
        if (!subjData[subjectName]) {
            subjData[subjectName] = {
                correct: 0,
                wrong: 0,
                blank: 0,
                total: 0,
                marks: 0
            };
        }
        
        const answer = progress.answers[i];
        const correctAnswer = examData.keys[i];
        
        if (answer === null) {
            subjData[subjectName].blank++;
        } else if (answer === correctAnswer) {
            subjData[subjectName].correct++;
            subjData[subjectName].marks += MARK_PER_CORRECT;
        } else {
            subjData[subjectName].wrong++;
            subjData[subjectName].marks += MARK_PER_WRONG;
        }
        
        subjData[subjectName].total++;
    }
    
    return subjData;
}

// ===== ENHANCED SUMMARY AND REVIEW FUNCTIONS =====
function showSummary(subjData) {
    document.getElementById('examArea').style.display = 'none';
    document.getElementById('summaryArea').style.display = 'block';
    
    const student = progress.student;
    document.getElementById('summaryStudentName').textContent = student.name;
    document.getElementById('summarySection').textContent = student.sec;
    document.getElementById('summaryRoll').textContent = student.roll;
    document.getElementById('summaryAdm').textContent = student.adm;
    document.getElementById('summaryForm').textContent = assignedForm;
    
    const tableContainer = document.getElementById('summaryTableContainer');
    tableContainer.innerHTML = createSummaryTable(subjData);
    
    const timeUsed = EXAM_DURATION_MS - (progress.timeLeftSec * 1000);
    const timeRemaining = EXAM_DURATION_MS - timeUsed;
    
    if (timeRemaining > 0) {
        startWaitingTimer(timeRemaining);
    } else {
        showAutoTransition();
    }
}

function createSummaryTable(subjData) {
    let tableHTML = `
        <table class="results-table">
            <thead>
                <tr>
                    <th>Subject</th>
                    <th>Correct</th>
                    <th>Wrong</th>
                    <th>Blank</th>
                    <th>Total</th>
                    <th>Marks</th>
                </tr>
            </thead>
            <tbody>
    `;
    
    let totalCorrect = 0, totalWrong = 0, totalBlank = 0, totalMarks = 0;
    
    for (const [subject, data] of Object.entries(subjData)) {
        tableHTML += `
            <tr>
                <td>${subject}</td>
                <td>${data.correct}</td>
                <td>${data.wrong}</td>
                <td>${data.blank}</td>
                <td>${data.total}</td>
                <td>${data.marks.toFixed(2)}</td>
            </tr>
        `;
        
        totalCorrect += data.correct;
        totalWrong += data.wrong;
        totalBlank += data.blank;
        totalMarks += data.marks;
    }
    
    tableHTML += `
            <tr class="total-row">
                <td><strong>Total</strong></td>
                <td><strong>${totalCorrect}</strong></td>
                <td><strong>${totalWrong}</strong></td>
                <td><strong>${totalBlank}</strong></td>
                <td><strong>${totalCorrect + totalWrong + totalBlank}</strong></td>
                <td><strong>${totalMarks.toFixed(2)}</strong></td>
            </tr>
        </tbody>
        </table>
    `;
    
    return tableHTML;
}

function startWaitingTimer(timeRemaining) {
    let remainingMs = timeRemaining;
    
    waitingTimerInterval = setInterval(() => {
        remainingMs -= 1000;
        
        const minutes = Math.floor(remainingMs / 60000);
        const seconds = Math.floor((remainingMs % 60000) / 1000);
        
        document.getElementById('waitingTimer').textContent = 
            `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        
        if (remainingMs <= 0) {
            clearInterval(waitingTimerInterval);
            showAutoTransition();
        }
    }, 1000);
}

function showAutoTransition() {
    document.getElementById('waitingMessage').style.display = 'none';
    document.getElementById('autoTransitionMessage').style.display = 'block';
    
    let countdown = 5;
    document.getElementById('countdown').textContent = countdown;
    
    autoTransitionTimer = setInterval(() => {
        countdown--;
        document.getElementById('countdown').textContent = countdown;
        
        if (countdown <= 0) {
            clearInterval(autoTransitionTimer);
            showDetailedSolutions();
        }
    }, 1000);
}

function showDetailedSolutions() {
    document.getElementById('summaryArea').style.display = 'none';
    document.getElementById('reviewArea').style.display = 'block';
    
    const student = progress.student;
    document.getElementById('reviewStudentName').textContent = student.name;
    document.getElementById('reviewSection').textContent = student.sec;
    document.getElementById('reviewRoll').textContent = student.roll;
    document.getElementById('reviewAdm').textContent = student.adm;
    document.getElementById('reviewForm').textContent = assignedForm;
    
    const detailedContainer = document.getElementById('detailedResultsContainer');
    detailedContainer.innerHTML = createDetailedResultsTable(currentSubjData);
    
    createQuestionReview();
}

function createDetailedResultsTable(subjData) {
    let tableHTML = `
        <table class="detailed-results-table">
            <thead>
                <tr>
                    <th>Subject</th>
                    <th>Correct</th>
                    <th>Wrong</th>
                    <th>Blank</th>
                    <th>Total Questions</th>
                    <th>Marks Obtained</th>
                    <th>Percentage</th>
                </tr>
            </thead>
            <tbody>
    `;
    
    let totalCorrect = 0, totalWrong = 0, totalBlank = 0, totalMarks = 0, totalQuestions = 0;
    
    for (const [subject, data] of Object.entries(subjData)) {
        const percentage = ((data.marks / (data.total * MARK_PER_CORRECT)) * 100).toFixed(2);
        
        tableHTML += `
            <tr>
                <td><strong>${subject}</strong></td>
                <td>${data.correct}</td>
                <td>${data.wrong}</td>
                <td>${data.blank}</td>
                <td>${data.total}</td>
                <td>${data.marks.toFixed(2)}</td>
                <td>${percentage}%</td>
            </tr>
        `;
        
        totalCorrect += data.correct;
        totalWrong += data.wrong;
        totalBlank += data.blank;
        totalMarks += data.marks;
        totalQuestions += data.total;
    }
    
    const overallPercentage = ((totalMarks / (totalQuestions * MARK_PER_CORRECT)) * 100).toFixed(2);
    
    tableHTML += `
            <tr class="total-row">
                <td><strong>GRAND TOTAL</strong></td>
                <td><strong>${totalCorrect}</strong></td>
                <td><strong>${totalWrong}</strong></td>
                <td><strong>${totalBlank}</strong></td>
                <td><strong>${totalQuestions}</strong></td>
                <td><strong>${totalMarks.toFixed(2)}</strong></td>
                <td><strong>${overallPercentage}%</strong></td>
            </tr>
        </tbody>
        </table>
    `;
    
    return tableHTML;
}

function createQuestionReview() {
    const container = document.getElementById('reviewQuestionsContainer');
    container.innerHTML = '<h3>Question-wise Analysis</h3>';
    
    for (let i = 0; i < examData.files.length; i++) {
        const questionDiv = document.createElement('div');
        questionDiv.className = 'question-review-item';
        questionDiv.style.cssText = 'border: 1px solid #ddd; padding: 15px; margin: 10px 0; background: white;';
        
        const studentAnswer = progress.answers[i];
        const correctAnswer = examData.keys[i];
        const isCorrect = studentAnswer === correctAnswer;
        const isAttempted = studentAnswer !== null;
        
        let statusClass = '', statusText = '', statusEmoji = '';
        
        if (!isAttempted) {
            statusClass = 'not-attempted';
            statusText = 'Not Attempted';
            statusEmoji = '‚ö™';
        } else if (isCorrect) {
            statusClass = 'correct';
            statusText = 'Correct';
            statusEmoji = '‚úÖ';
        } else {
            statusClass = 'wrong';
            statusText = 'Wrong';
            statusEmoji = '‚ùå';
        }
        
        questionDiv.innerHTML = `
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                <h4 style="margin: 0;">Question ${i + 1}</h4>
                <div class="answer-status ${statusClass}" style="padding: 5px 10px; border-radius: 3px;">
                    ${statusEmoji} ${statusText}
                </div>
            </div>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 10px;">
                <div>
                    <strong>Your Answer:</strong> 
                    <span style="${isAttempted ? (isCorrect ? 'color: green; font-weight: bold;' : 'color: red; font-weight: bold;') : ''}">
                        ${isAttempted ? studentAnswer : 'Not Attempted'}
                    </span>
                </div>
                <div>
                    <strong>Correct Answer:</strong> 
                    <span style="color: green; font-weight: bold;">${correctAnswer}</span>
                </div>
            </div>
            
            <div style="text-align: center;">
                <img src="${examData.files[i]}" 
                     alt="Question ${i + 1}" 
                     style="max-width: 100%; height: auto;"
                     onerror="this.style.display='none'">
            </div>
        `;
        
        container.appendChild(questionDiv);
    }
}

function showSubmissionError() {
    const errorDiv = document.createElement('div');
    errorDiv.innerHTML = `
        <div style="background: #f8d7da; border: 1px solid #f5c6cb; border-radius: 4px; 
                   padding: 10px; margin: 15px 0; text-align: center; font-weight: bold;">
            ‚ö†Ô∏è Submission Error: Your results may not have been recorded. 
            Please contact the administrator.
        </div>
    `;
    
    const summaryArea = document.getElementById('summaryArea');
    if (summaryArea) {
        summaryArea.prepend(errorDiv);
    }
}

// ===== ENHANCED INITIALIZATION =====
document.addEventListener('DOMContentLoaded', function() {
    console.log('üöÄ Initializing ENHANCED LFJC Examination System');
    
    sessionId = Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    
    for (let i = 1; i <= answerKey.length; i++) {
        images.push(`questions/${i}.png?v=2.0`);
    }
    
    window.submissionManager = new EnhancedSubmissionManager();
    window.networkManager = new EnhancedNetworkManager();
    window.dataManager = new EnhancedDataManager();
    
    setupScreenshotProtection();
    setupTabSwitchDetection();
    setupPowerFailureProtection();
    
    checkForResumeOption();
    initializeEventListeners();
    
    console.log('‚úÖ ENHANCED LFJC Examination System Ready');
});

function initializeEventListeners() {
    document.getElementById('stuName').addEventListener('input', function() {
        validateNameInput(this);
        validateStudentInputs();
    });
    
    document.getElementById('stuSection').addEventListener('input', function() {
        validateSectionInput(this);
        validateStudentInputs();
    });
    
    document.getElementById('stuRoll').addEventListener('input', function() {
        validateRollInput(this);
        validateStudentInputs();
    });
    
    document.getElementById('stuAdm').addEventListener('input', function() {
        validateAdmInput(this);
        validateStudentInputs();
    });
    
    document.getElementById('stuStartBtn').addEventListener('click', startWithSecurity);
    
    document.getElementById('resumeExamBtn').addEventListener('click', resumeExam);
    
    document.getElementById('adminOverrideBtn').addEventListener('click', function() {
        const password = document.getElementById('adminOverridePass').value;
        if (password === ADMIN_PASSWORD) {
            hideAccessDeniedOverlay();
            document.getElementById('stuStartBtn').style.display = 'block';
        } else {
            alert('Incorrect admin password!');
        }
    });
}

function checkForResumeOption() {
    try {
        for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key && key.startsWith('exam_backup_')) {
                document.getElementById('resumeExamSection').style.display = 'block';
                break;
            }
        }
    } catch (error) {
        console.warn('Resume check failed:', error);
    }
}

function startWithSecurity(forceStart = false) {
    if (!validateStudentInputs() && !forceStart) return;
    
    const studentData = {
        name: document.getElementById('stuName').value.trim(),
        sec: document.getElementById('stuSection').value.trim(),
        roll: document.getElementById('stuRoll').value.trim(),
        adm: document.getElementById('stuAdm').value.trim()
    };
    
    if (!forceStart && !check24HourCooldown(studentData)) {
        showAccessDeniedOverlay();
        return;
    }
    
    if (!forceStart && checkForDuplicateSubmission(studentData)) {
        showDuplicateWarning(studentData);
        return;
    }
    
    const studentId = generateStudentId(studentData);
    window.dataManager.clearBackup(studentId);
    
    startExam(studentData);
}

function startExam(studentData) {
    examInProgress = true;
    examStartTime = Date.now();
    tabSwitchDetected = false;
    
    assignedForm = getAssignedForm(studentData);
    examData = shuffleQuestionsForStudent(studentData);
    
    progress = {
        student: studentData,
        answers: new Array(examData.files.length).fill(null),
        currentQ: 0,
        timeLeftSec: EXAM_DURATION_MS / 1000,
        markedReview: new Set(),
        sessionId: sessionId
    };
    
    document.getElementById('studentEntry').style.display = 'none';
    document.getElementById('examArea').style.display = 'block';
    document.getElementById('examWarning').style.display = 'block';
    
    document.getElementById('stuInfo').textContent = 
        `${studentData.name} | ${studentData.sec} | Roll: ${studentData.roll}`;
    
    startTimer();
    initPalette();
    showQuestion(0);
    backupExamProgress();
}

function resumeExam() {
    document.getElementById('resumeExamSection').style.display = 'none';
    alert('Please start a new exam session. Resume functionality requires proper student identification.');
}
</script>
</body>
</html>
